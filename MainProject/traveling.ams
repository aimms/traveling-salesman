## ams_version=1.0

Model Main_TravelingSalesman {
	Comment: {
		"This model illustrates some of AIMMS control flow statements by means of the
		traveling salesman 2-opt heuristic. You will find some declarations to define
		the problem, along with
		- a procedure and some declarations to compute and visualize an initial tour
		  constructed by starting at some city and successively selecting the next
		  city as the closest city not yet part of the tour
		- a procedure and some declarations to compute and visualize an improved tour
		  constructed by repetitively swapping those two arcs in the tour by means of
		  the 2-opt heuristic that give the largest overall distance improvement, until
		  no further improvement is possible or the iteration limit is reached
		- a procedure and some declarations to compute and visualize an improved tour
		  constructed by repetitively swapping the next arc in the (modified) tour
		  with that neighbor arc which gives the largest distance improvement, until
		  the iteration limit is reached or a full cycle over the tour gives no
		  further improvement.
		  
		  Keywords:
		  Algorithm, network object, traveling salesman problem, GMP, Progress Window."
	}
	Section Data_Model {
		Section Quantities_and_Units {
			Comment: {
				"This section contains all the units and quantities that are added automatically by AIMMS.
				It is recommended to declare all your quantities here."
			}
			Quantity SI_Time_Duration {
				BaseUnit: s;
				Conversions: minute->s : #-># * 60;
				Comment: {
					"Expresses the value for the duration of periods.
					
					The unit s has been added automatically because it is a required unit for AimmsWebUI.
					
					The unit minute has been added automatically because it is a required unit for AimmsWebUI."
				}
			}
		}
		Section Inputs {
			DeclarationSection DB_Inputs {
				Set s_ids {
					Index: i_id;
					Parameter: ep_id;
				}
				Set s_cities {
					Text: "The set of cities in the tour";
					Index: i_city1, i_city2, i_city;
					Parameter: ep_city;
					webui::AnnotationsIdentifier: sp_def_nodeAnnotation;
				}
				Set s_citiesASCII {
					Index: i_city_ascii;
					Parameter: ep_cityASCII;
				}
				Set s_countries {
					Index: i_country;
					Parameter: ep_country;
				}
				Set s_provinces {
					Index: i_province;
					Parameter: ep_province;
				}
				StringParameter sp_countryAcronym {
					IndexDomain: i_country;
				}
				Parameter bp_city_x_country {
					IndexDomain: (i_city,i_country);
				}
				Parameter bp_city_x_id {
					IndexDomain: (i_city,i_id);
				}
				Parameter bp_city_x_cityASCII {
					IndexDomain: (i_city,i_city_ascii);
				}
				Parameter bp_city_x_province {
					IndexDomain: (i_city,i_province);
				}
			}
			DeclarationSection API_Inputs {
				Set s_nodes {
					SubsetOf: s_cities;
					Index: i_node1, i_node2;
					Parameter: ep_node;
					Definition: {
						{i_city | 
						        p_latitude(i_city)
						        and p_longitude(i_city)}
					}
				}
				Set s_subtours {
					SubsetOf: s_nodes;
				}
				Parameter p_def_cardinalityOfNodes {
					Definition: card(s_nodes);
				}
				Set s_neighbors {
					IndexDomain: i_node1;
					SubsetOf: s_cities;
					Text: "The set of neighbors of city i";
					OrderBy: user;
					Definition: NBest(i_node2 | (i_node1 <> i_node2), -p_def_haversineDistance(i_node1,i_node2), p_def_maxNeighbors);
				}
				Parameter p_maxCities {
					Text: "Maximum number of cities in the tour";
					Range: {
						{-inf..inf}
					}
					Default: 100;
					InitialData: 100;
				}
				Parameter p_latitude {
					IndexDomain: i_city;
					Text: "X-Coordinate of city c";
					InitialData: 0;
				}
				Parameter p_longitude {
					IndexDomain: i_city;
					Text: "Y-Coordinate of city c";
					InitialData: 0;
				}
				Parameter p_def_haversineDistance {
					IndexDomain: (i_node1,i_node2) | i_node1 <> i_node2;
					Text: "Distance from city i to city j";
					Definition: {
						((6371.0 ) * arccos[cos(radians(90 - P_latitude(i_node1)))*
						           cos(radians(90 - P_latitude(i_node2))) 
						         + 
						        sin(radians(90 - P_latitude(i_node1)))* 
						           sin(radians(90 - P_latitude(i_node2)))*
						           cos(radians(p_longitude(i_node1)-p_longitude(i_node2)))
						      ] )
					}
					Comment: {
						"! Formula also present on http://www.movable-type.co.uk/scripts/latlong.html section Spherical Law of Cosines.
						! calculate distance from haversine formulas"
					}
				}
				Parameter p_def_iterationLimit {
					Text: "Maximum number of iterations to improve tour";
					Definition: {
						floor(card(s_nodes) / 3);
					}
				}
				Parameter p_def_maxNeighbors {
					Text: "Maximum number of neighbors considered for each city";
					Definition: {
						floor(Sqrt(p_maxCities));
					}
				}
			}
		}
		Section Math_Model {
			Section Heuristic {
				Procedure pr_runAll {
					Body: {
						pr_findInitialTour;
						pr_improveTourCyclic;
						pr_improveTourSimultaneous;
					}
				}
				Section Initial_Tour {
					Comment: {
						"This section contains all declarations and procedures necessary to
						compute and visualize the initial tour."
					}
					Parameter p_init_tourDistance {
						Text: "Total distance of the initial tour";
					}
					Parameter p_init_tourConnect {
						IndexDomain: (i_node1,i_node2);
						Text: "City i connected to city j in initial tour";
						webui::TooltipIdentifier: sp_def_arcTooltip(i_node1,i_node2);
					}
					ElementParameter ep_init_nextCity {
						IndexDomain: i_city;
						Text: "Next city of city c in initial tour";
						Range: s_cities;
					}
					ElementParameter ep_init_prevCity {
						IndexDomain: i_city;
						Text: "Previous city of city c in initial tour";
						Range: s_cities;
					}
					Parameter p_init_tourInitialized {
						Text: "Flag to indicate that an initial tour has been computed for a newly created tour";
					}
					Procedure pr_findInitialTour {
						Body: {
							empty Initial_Tour, p_init_tourConnect;
							
							s_loc_remainingCities := s_nodes;
							
							! We start adding the first city to the tour
							ep_node := First(s_nodes);
							s_loc_remainingCities -= ep_node;
							
							! For every other city, the next city in the tour is the one closest to it not yet chosen
							while (Card(s_loc_remainingCities) <> 0) do
							    ep_init_nextCity(ep_node) 
							    :=  argmin(i_node1 in s_loc_remainingCities, p_def_haversineDistance(ep_node,i_node1));
							
							    ep_node := ep_init_nextCity(ep_node);
							    s_loc_remainingCities -= ep_node;
							endwhile;
							
							! Finally, close the tour
							ep_init_nextCity(ep_node) := First(s_nodes);
							
							ep_init_prevCity(ep_init_nextCity(i_node1)) := i_node1;
							p_init_tourConnect(i_node1,ep_init_nextCity(i_node1)) := 1;
							p_init_tourDistance := sum(i_node1, p_def_haversineDistance(i_node1,ep_init_nextCity(i_node1)));
							
							p_init_tourInitialized := 1;
						}
						Comment: {
							"This procedure computes an initial tour by starting at the first city,
							and successively adding the closest remaining city."
						}
						Set s_loc_remainingCities {
							SubsetOf: s_cities;
						}
					}
				}
				Section Improve_Tour_Simultaneous {
					Comment: {
						"This section contains all identifiers and the procedure necessary to compute
						and visualize improved tours using an algorithm that selects the neighbor of a
						city for swapping, considering all cities in the tour simultaneously."
					}
					Parameter p_sim_distanceChange {
						IndexDomain: (i_node1,i_node2);
						Text: "Improvement in total tour distance by swapping city i with neighbor j in simultaneous algorithm";
						Default: -inf;
						Definition: p_def_haversineDistance(i_node1,p_sim_nextCity(i_node1)) + p_def_haversineDistance(i_node2,p_sim_nextCity(i_node2)) - (p_def_haversineDistance(i_node1,i_node2) + p_def_haversineDistance(p_sim_nextCity(i_node1),p_sim_nextCity(i_node2)));
					}
					Parameter p_sim_maxChange {
						Text: "Maximum possible distance improvement in simultaneous algorithm";
						Definition: Max((i_node1,i_node2 in s_neighbors(i_node1)), p_sim_distanceChange(i_node1,i_node2));
					}
					Parameter p_sim_swaps {
						Text: "Number of performed swaps in simultaneous algorithm";
					}
					Parameter p_sim_tourDistance {
						Text: "Total tour distance after current iteration in simultaneous algorithm";
						InitialData: 0;
					}
					Parameter p_sim_tourConnect {
						IndexDomain: (i_node1,i_node2);
						Text: "City i connected to city j after current iteration in simultaneous algorithm";
					}
					ElementParameter p_sim_nextCity {
						IndexDomain: i_city;
						Text: "Next city of city c after current iteration in simultaneous algorithm";
						Range: s_cities;
					}
					ElementParameter p_sim_prevCity {
						IndexDomain: i_city;
						Text: "Previous city of city c after current iteration in simultaneous algorithm";
						Range: s_cities;
					}
					Parameter p_sim_initialized {
						Text: "Flag to indicate that simultaneous algorithm has been initialized";
					}
					Procedure pr_improveTourSimultaneous {
						Body: {
							empty Improve_Tour_Simultaneous;
							
							if not p_init_tourInitialized then 
							    pr_findInitialTour; 
							endif;
							
							if (not p_sim_initialized) then
							   p_sim_nextCity(i_node1) := ep_init_nextCity(i_node1);
							   p_sim_prevCity(i_node1) := ep_init_prevCity(i_node1);
							   p_sim_initialized := 1;
							   p_sim_swaps := 0;
							endif;
							
							while (p_sim_maxChange > 0 and LoopCount <= p_def_iterationLimit) do
							
							    p_sim_swaps += 1;
							
							    ! Select City and NewNext as a (i,j) tuple which reaches the maximum change
							    for ((i_node1,i_node2) | p_sim_distanceChange(i_node1,i_node2) = p_sim_maxChange) do
							        ep_node := i_node1;
							        ep_loc_nextCity := i_node2;
							        break;
							    endfor;
							
							    block ! Swap cities in tour.
							        ! This is the hairy part of the algorithm. The direction of the tour changes from
							        ! City to NewNext as part of the 2-opt heuristic. To modify the next and previous
							        ! city references we have to walk over the subtour, carefully making sure we don't
							        ! destroy any information while reversing the direction.
							
							        ! Set up a link from the old destinations of City to the old destination of NewNext in the tour
							        ep_loc_OCity := p_sim_nextCity(ep_node);
							        ep_loc_DCity := p_sim_nextCity(ep_loc_nextCity);
							        p_sim_nextCity(ep_loc_OCity) := ep_loc_DCity;
							        p_sim_prevCity(ep_loc_DCity) := ep_loc_OCity;
							
							        ! Reverse the chain from the old destination of City to NextNew
							        ep_loc_OCity := ep_loc_nextCity;
							        ep_loc_DCity := p_sim_prevCity(ep_loc_OCity);
							
							        while ( ep_loc_DCity <> ep_node ) do
							            ep_loc_ODCity := ep_loc_DCity;
							            p_sim_nextCity(ep_loc_OCity) := ep_loc_ODCity;
							            ep_loc_DCity := p_sim_prevCity(ep_loc_ODCity);
							            p_sim_prevCity(ep_loc_ODCity) := ep_loc_OCity;
							            ep_loc_OCity := ep_loc_ODCity;
							        endwhile;
							
							        ! Finally, setup the link from City to NextNew
							        p_sim_nextCity(ep_node) := ep_loc_nextCity;
							        p_sim_prevCity(ep_loc_nextCity) := ep_node;
							    endblock; 
							
							    block ! Update network flow object.
							        empty p_sim_tourConnect;
							        p_sim_tourConnect(i_node1, p_sim_nextCity(i_node1)) := 1;
							        p_sim_tourDistance := sum(i_node1, p_def_haversineDistance(i_node1, p_sim_nextCity(i_node1)));
							    endblock; 
							
							endwhile;
						}
						ElementParameter ep_loc_nextCity {
							Range: s_cities;
						}
						ElementParameter ep_loc_OCity {
							Range: s_cities;
						}
						ElementParameter ep_loc_DCity {
							Range: s_cities;
						}
						ElementParameter ep_loc_ODCity {
							Range: s_cities;
						}
					}
				}
				Section Improve_Tour_Cyclic {
					Comment: {
						"This section contains all identifiers and the procedure necessary to compute
						and visualize improved tours using an algorithm that selects that neighbor of the
						next city in the (modified) tour for swapping which causes the largest distance
						improvement."
					}
					Macro p_cyc_distanceChange {
						Text: "Improvement in total tour distance by swapping city i with neighbor j in cyclic algorithm";
						Arguments: (i_node1,i_node2);
						Definition: p_def_haversineDistance(i_node1,p_cyc_nextCity(i_node1)) + p_def_haversineDistance(i_node2,p_cyc_nextCity(i_node2)) - (p_def_haversineDistance(i_node1,i_node2) + p_def_haversineDistance(p_cyc_nextCity(i_node1),p_cyc_nextCity(i_node2)));
					}
					Parameter p_cyc_swaps {
						Text: "Number of performed swaps in cyclic algorithm";
					}
					Parameter p_cyc_tourDistance {
						Text: "Total tour distance after current iteration in cyclic algorithm";
						InitialData: 0;
					}
					Parameter p_cyc_tourConnect {
						IndexDomain: (i_node1,i_node2);
						Text: "City i connected to city j after current iteration in cyclic algorithm";
					}
					ElementParameter p_cyc_nextCity {
						IndexDomain: i_city;
						Text: "Next city of city c after current iteration in cyclic algorithm";
						Range: s_cities;
					}
					ElementParameter p_cyc_prevCity {
						IndexDomain: i_city;
						Text: "Previous city of city c after current iteration in cyclic algorithm";
						Range: s_cities;
					}
					Parameter p_cyc_initialized {
						Text: "Flag to indicate that cyclic algorithm has been initialized";
					}
					Procedure pr_improveTourCyclic {
						Body: {
							empty Improve_Tour_Cyclic;
							
							if not p_init_tourInitialized then 
							    pr_findInitialTour; 
							endif;
							
							if (not p_cyc_initialized) then
							   p_cyc_nextCity(i_node1) := ep_init_nextCity(i_node1);
							   p_cyc_prevCity(i_node1) := ep_init_prevCity(i_node1);
							   p_cyc_initialized := 1;
							   p_cyc_swaps := 0;
							endif;
							
							p_loc_uselessLoops := 0;
							ep_node := First(s_nodes);
							
							while (p_cyc_swaps < p_def_iterationLimit 
							        and p_loc_uselessLoops <= card(s_nodes)) do
							
							    p_loc_uselessLoops += 1;
							
							    ! Select a NewNext to be swapped with City
							    ep_loc_nextCity := argmax(i_node1 in s_neighbors(ep_node), p_cyc_distanceChange(ep_node,i_node1));
							
							    if (p_cyc_distanceChange(ep_node, ep_loc_nextCity) > 0) then
							        p_cyc_swaps += 1;
							        p_loc_uselessLoops := 0;
							
							        block ! Swap cities in tour.
							            ! This is the hairy part of the algorithm. The direction of the tour changes from
							            ! City to NewNext as part of the 2-opt heuristic. To modify the next and previous
							            ! city references we have to walk over the subtour, carefully making sure we don't
							            ! destroy any information while reversing the direction.
							
							            ! Set up a link from the old destinations of City to the old destination of NewNext in the tour
							            ep_loc_OCity := p_cyc_NextCity(ep_node);
							            ep_loc_DCity := p_cyc_nextCity(ep_loc_nextCity);
							            p_cyc_nextCity(ep_loc_OCity) := ep_loc_DCity;
							            p_cyc_prevCity(ep_loc_DCity) := ep_loc_OCity;
							
							            ! Reverse the chain from the old destination of City to NextNew
							            ep_loc_OCity := ep_loc_nextCity;
							            ep_loc_DCity := p_cyc_prevCity(ep_loc_OCity);
							
							            while ( ep_loc_DCity <> ep_node ) do
							                 ep_loc_ODCity := ep_loc_DCity;
							                 p_cyc_NextCity(ep_loc_OCity) := ep_loc_ODCity;
							                 ep_loc_DCity := p_cyc_prevCity(ep_loc_ODCity);
							                 p_cyc_prevCity(ep_loc_ODCity) := ep_loc_OCity;
							                 ep_loc_OCity := ep_loc_ODCity;
							            endwhile;
							
							            ! Finally, setup the link from City to NextNew
							            p_cyc_NextCity(ep_node) := ep_loc_nextCity;
							            p_cyc_PrevCity(ep_loc_nextCity) := ep_node;
							        endblock;
							
							        block ! Update network flow object.
							            empty p_cyc_tourConnect;
							            p_cyc_TourConnect(i_node1,p_cyc_NextCity(i_node1)) := 1;
							            p_cyc_TourDistance := sum(i_node1, p_def_haversineDistance(i_node1,p_cyc_nextCity(i_node1)));
							
							        endblock;
							    endif;
							
							    ep_node := p_cyc_nextCity(ep_node);
							endwhile;
						}
						Parameter p_loc_uselessLoops {
							Text: "Counter for counting number of iterations without tour improvement";
						}
						ElementParameter ep_loc_nextCity {
							Range: s_cities;
						}
						ElementParameter ep_loc_OCity {
							Range: s_cities;
						}
						ElementParameter ep_loc_DCity {
							Range: s_cities;
						}
						ElementParameter ep_loc_ODCity {
							Range: s_cities;
						}
					}
				}
			}
			Section Exact {
				Set s_TSPConstraints {
					SubsetOf: AllConstraints;
					Definition: AllConstraints - data { 'c_subtourElimination' };
				}
				MathematicalProgram mp_TSP {
					Objective: v_objective;
					Direction: minimize;
					Constraints: s_TSPConstraints;
					Variables: AllVariables;
					Type: ep_modelType;
				}
				Variable v_objective {
					Range: free;
					Definition: sum( (i_node1,i_node2), p_def_haversineDistance(i_node1,i_node2) * v_networkTour(i_node1,i_node2) );
				}
				Variable v_networkTour {
					IndexDomain: (i_node1,i_node2) | i_node1 > i_node2;
					Range: binary;
					RelaxStatus: p_relaxStatus;
				}
				Constraint c_subtourElimination {
					Definition: {
						sum((i_node1,i_node2) | 
						        i_node1 in s_subtours 
						        and not i_node2 in s_subtours, 
						    v_networkTour(i_node1,i_node2) 
						    + v_networkTour(i_node2,i_node1)) 
						>= 2
					}
				}
				Constraint c_degreeCheck {
					IndexDomain: i_node2;
					Definition: {
						sum(i_node1, 
						    v_networkTour(i_node1,i_node2) 
						    + v_networkTour(i_node2,i_node1)) 
						= 2
					}
				}
				ElementParameter ep_GMP {
					Range: AllGeneratedMathematicalPrograms;
				}
				Parameter p_calc_solutionTour {
					IndexDomain: (i_node1,i_node2);
				}
				Parameter bp_showSolutionWithSubtours {
					Text: "Show incumbents with subtours";
					Range: binary;
					Property: NoSave;
					InitialData: 1;
				}
				Parameter p_exactObjective;
				Parameter p_relaxStatus {
					InitialData: 0;
				}
				ElementParameter ep_modelType {
					Range: AllMathematicalProgrammingTypes;
				}
				Procedure pr_callbackLazy {
					Arguments: ep_in_thisSession;
					Body: {
						! Retrieve solution from solver session and send it to the AIMMS variables.
						GMP::Solution::RetrieveFromSolverSession(ep_in_thisSession, 1);
						GMP::Solution::SendToModelSelection(ep_GMP, 1, AllVariables, Suffices);
						
						pr_determineSubtours(ep_in_thisSession);
						
						return 1;
					}
					ElementParameter ep_in_thisSession {
						Range: AllSolverSessions;
						Property: Input;
					}
					Set Suffices {
						SubsetOf: AllSuffixNames;
						InitialData: data { 'Level' };
					}
				}
				Procedure pr_determineSubtours {
					Arguments: ep_in_thisSession;
					Body: {
						empty s_subtours, p_loc_foundSubtour;
						
						s_loc_remainingCities := s_nodes;
						
						! We start adding the first city to the tour.
						ep_loc_firstCity := First(s_loc_remainingCities);
						ep_loc_city := ep_loc_firstCity;
						s_loc_remainingCities -= ep_loc_city;
						s_subtours := ep_loc_city;
						
						while Card(s_loc_remainingCities) > 0 do
							! For every other city, the next city in the tour is the one closest to it not yet chosen.
						    ep_loc_initNextCity(ep_loc_city) 
						    :=  argmax(i_city in s_loc_remainingCities, 
						            v_networkTour(ep_loc_city, i_city) 
						            + v_networkTour(i_city, ep_loc_city));
						
						    if (v_networkTour(ep_loc_city, ep_loc_initNextCity(ep_loc_city)) + v_networkTour(ep_loc_initNextCity(ep_loc_city), ep_loc_city) > 0.5) then
						    	! Add city to current (sub)tour.
						    	ep_loc_city := ep_loc_initNextCity(ep_loc_city);
						    	s_loc_remainingCities -= ep_loc_city;
						    	s_subtours += ep_loc_city;
						    else
						    	! Close the (sub)tour.
						    	ep_loc_initNextCity(ep_loc_city) := ep_loc_firstCity;
						
						    	if Card(s_subtours) < Card(s_nodes) then
						    		! Add lazy constraints that forbid the subtour just found.
									GMP::SolverSession::GenerateCut(ep_in_thisSession, c_subtourElimination);
									p_loc_foundSubtour := 1;
								endif;
						
								! Start next subtour by adding the first remaining city.
						    	ep_loc_firstCity := First(s_loc_remainingCities);
								ep_loc_city := ep_loc_firstCity;
								s_loc_remainingCities -= ep_loc_city;
								s_subtours := ep_loc_city;
						    endif;
						endwhile;
						
						! Finally, close the last subtour.
						ep_loc_initNextCity(ep_loc_city) := ep_loc_firstCity;
						
						if Card(s_subtours) < Card(s_nodes) then
							! Add lazy constraints that forbid the last subtour.
							GMP::SolverSession::GenerateCut(ep_in_thisSession, c_subtourElimination);
							p_loc_foundSubtour := 1;
						endif;
						
						! Determine tour to display on page.
						if not p_loc_foundSubtour 
						    or bp_showSolutionWithSubtours then
						
							empty p_calc_solutionTour;
							p_calc_solutionTour(i_city, ep_loc_initNextCity(i_city)) := 1;
						endif;
					}
					Comment: {
						"This lazy constraint callback is called whenever the solver finds a new candidate incumbent
						solution. It checks whether the incumbent solution found by the solver contains subtours.
						If yes, then subtour elimination constraints are added, using GMP::SolverSession::GenerateCut,
						that forbid these subtours. If not, then the incumbent solution forms a true solution of the
						TSP problem, as it contains only one tour."
					}
					Set s_loc_remainingCities {
						SubsetOf: s_nodes;
					}
					ElementParameter ep_in_thisSession {
						Range: AllSolverSessions;
						Property: Input;
					}
					ElementParameter ep_loc_city {
						Range: s_nodes;
					}
					ElementParameter ep_loc_firstCity {
						Range: s_nodes;
					}
					ElementParameter ep_loc_initNextCity {
						IndexDomain: i_city;
						Range: s_nodes;
					}
					Parameter p_loc_foundSubtour {
						Range: binary;
					}
				}
				Procedure pr_emptyExactSolution {
					Body: {
						empty v_networkTour, p_calc_solutionTour;
						
						MonitoredIdentifiers := AllIdentifiers;
						
						DataChangeMonitorReset(DataManagementMonitorID, MonitoredIdentifiers);
					}
					Comment: {
						"To avoid a dialog that will ask the user to save the case if the \'Select instance\'
						button is pressed."
					}
					Set MonitoredIdentifiers {
						SubsetOf: AllIdentifiers;
					}
				}
				Procedure pr_solveModel {
					Body: {
						empty p_calc_solutionTour;
						
						p_relaxStatus := 0;
						ep_modelType := 'MIP';
						
						ep_GMP := GMP::Instance::Generate(mp_TSP);
						
						GMP::Instance::SetCallbackAddLazyConstraint(ep_GMP, 'pr_callbackLazy');
						
						GMP::Instance::Solve(ep_GMP);
						
						if GMP::Solution::Count(ep_GMP) >= 1 then
							pr_determineSubtours('');
						endif;
						
						p_exactObjective := v_objective;
					}
				}
				Section Lower_Bound {
					Parameter p_relaxedTourSolution {
						IndexDomain: (i_node1,i_node2);
					}
					Parameter p_lowerBound;
					Procedure pr_solveRelaxedModel {
						Body: {
							empty Lower_Bound;
							
							p_relaxStatus := 1;
							ep_modelType := 'LP';
							
							ep_GMP := GMP::Instance::Generate(mp_TSP);
							GMP::Instance::SetCallbackAddLazyConstraint(ep_GMP, 'pr_callbackLazy');
							
							GMP::Instance::Solve(ep_GMP);
							
							p_relaxedTourSolution(i_node1, i_node2) := v_networkTour(i_node1,i_node2);
							p_lowerBound := v_objective;
						}
					}
				}
			}
		}
	}
	Section UI_Declarations {
		StringParameter sp_logo {
			InitialData: "aimms_logo.png";
		}
		Section Workflow {
			StringParameter sp_myWorkflows {
				IndexDomain: (webui::indexWorkflowOrder,webui::indexWorkflowSpec);
			}
			StringParameter sp_myWorkflowSteps {
				IndexDomain: (webui::indexWorkflowOrder,webui::indexNoOfPages,webui::indexWorkflowPageSpec);
				Definition: {
					data 
					{ ( 1, 1, displayText       ) : "Welcome"             ,  ( 1, 1, icon              ) : "aimms-happy"         ,
					  ( 1, 1, pageId            ) : "home"                ,  ( 1, 1, tooltip           ) : "Welcome"             ,
					  ( 1, 1, workflowPageState ) : "active"              ,  ( 1, 1, pageDataState     ) : "Incomplete"          ,
					  ( 1, 1, redirectPageId    ) : "home"                ,  ( 1, 2, displayText       ) : "Story"               ,
					  ( 1, 2, icon              ) : "aimms-lamp5"         ,  ( 1, 2, pageId            ) : "story"               ,
					  ( 1, 2, tooltip           ) : "Problem description" ,  ( 1, 2, workflowPageState ) : "active"              ,
					  ( 1, 2, pageDataState     ) : "Incomplete"          ,  ( 1, 2, redirectPageId    ) : "home"                ,
					  ( 1, 3, displayText       ) : "Network"             ,  ( 1, 3, icon              ) : "aimms-map"           ,
					  ( 1, 3, pageId            ) : "network"             ,  ( 1, 3, tooltip           ) : "Building the network",
					  ( 1, 3, workflowPageState ) : "active"              ,  ( 1, 3, pageDataState     ) : "Incomplete"          ,
					  ( 1, 3, redirectPageId    ) : "home"                ,  ( 1, 4, displayText       ) : "Heuristic"           ,
					  ( 1, 4, icon              ) : "aimms-finish"        ,  ( 1, 4, pageId            ) : "tours"               ,
					  ( 1, 4, tooltip           ) : "Heuristic tours"     ,  ( 1, 4, workflowPageState ) : "active"              ,
					  ( 1, 4, pageDataState     ) : "Incomplete"          ,  ( 1, 4, redirectPageId    ) : "home"                ,
					  ( 1, 5, displayText       ) : "Exact"               ,  ( 1, 5, icon              ) : "aimms-target"        ,
					  ( 1, 5, pageId            ) : "exact"               ,  ( 1, 5, tooltip           ) : "Exact tour"          ,
					  ( 1, 5, workflowPageState ) : "active"              ,  ( 1, 5, pageDataState     ) : "Incomplete"          ,
					  ( 1, 5, redirectPageId    ) : "home"                ,  ( 1, 6, displayText       ) : "Comparison"          ,
					  ( 1, 6, icon              ) : "aimms-trophy3"       ,  ( 1, 6, pageId            ) : "comparison"          ,
					  ( 1, 6, tooltip           ) : "Tour comparisons"    ,  ( 1, 6, workflowPageState ) : "active"              ,
					  ( 1, 6, pageDataState     ) : "Incomplete"          ,  ( 1, 6, redirectPageId    ) : "home"                 }
				}
			}
		}
		Section Pages {
			Section Network_Page {
				StringParameter sp_mapTitle {
					Definition: {
						"The network has " + card(s_nodes) + " nodes.";
					}
				}
				StringParameter sp_addThisCity;
				StringParameter sp_addByCountry;
				Parameter p_def_unableToFetch {
					InitialData: 0;
					webui::FlagsIdentifier: sp_readOnlyFlag;
				}
				StringParameter sp_def_nodeTooltip {
					IndexDomain: i_city | exists(i_node1 | i_node1 = i_city) or exists(i_node2 | i_node2 = i_city);
					Definition: {
						"<p style=\"text-align: left;\"><em>" + i_city + "</em></p>" +
						"<p style=\"text-align: left;\"><strong>Latitude: </strong>" + p_latitude(i_city) + "</p>" +
						"<p style=\"text-align: left;\"><strong>Longitude: </strong>" + p_longitude(i_city) + "</p>"
					}
				}
				Parameter p_def_nodeSize {
					IndexDomain: i_city;
					Definition: 2;
					webui::TooltipIdentifier: sp_def_nodeTooltip(i_city);
				}
				StringParameter sp_def_arcTooltip {
					IndexDomain: (i_node1,i_node2) | i_node1 <> i_node2;
					Definition: {
						"<p style=\"text-align: left;\">From <em>" + i_node1 + "</em> to <em>" + i_node2 + "</em>.</p>"
					}
				}
				StringParameter sp_def_nodeAnnotation {
					IndexDomain: i_city;
					Definition: "node";
				}
				StringParameter sp_def_nodeItemActions {
					IndexDomain: (webui::indexWidgetItemActionSpec,webui::indexPageExtension,webui::indexWidgetActionSpec);
					Definition: {
						data 
						{ ( p_def_nodeSize, 1, displaytext ) : "Delete this node"  ,  ( p_def_nodeSize, 1, icon        ) : "aimms-cross" ,
						  ( p_def_nodeSize, 1, procedure   ) : "pr_deleteNode"  ,  ( p_def_nodeSize, 1, state       ) : "active" }
					}
				}
				StringParameter sp_def_networkSidePanel {
					IndexDomain: (webui::indexPageExtension,webui::indexSidePanelSpec);
					Definition: data { ( 1, displayText ) : "Help",  ( 1, pageId ) : "network_help",  ( 1, icon ) : "aimms-info2",  ( 1, state ) : "active" };
				}
				Procedure pr_addThisCity {
					Body: {
						ep_city := StringToElement(s_cities, sp_addThisCity, 0);
						sp_loc_cityASCII := first(i_city_ascii | bp_city_x_cityASCII(ep_city, i_city_ascii));
						ep_loc_cityCountry := first(i_country | bp_city_x_country(ep_city, i_country));
						
						if ep_loc_cityCountry then
						    pr_callAPIQuery(sp_loc_cityASCII, ep_loc_cityCountry);
						else
						    raise error "No city with this name";   
						endif;
					}
					ElementParameter ep_loc_cityCountry {
						Range: s_countries;
					}
					StringParameter sp_loc_cityASCII;
				}
				Procedure pr_addByCountry {
					Body: {
						empty ep_country;
						
						ep_country := StringToElement(s_countries, sp_addByCountry, 0);
						p_loc_counter := 0;
						
						if sp_addByCountry and ep_country then
						    block 
						    p_loc_cardinalityOfCitiesFromCountry  
						    :=  sum(i_id | exists(i_city | 
						                    bp_city_x_id(i_city, i_id) 
						                    and bp_city_x_country(i_city, ep_country)), 1);
						
						    s_loc_newIds := {1 .. p_loc_cardinalityOfCitiesFromCountry};
						    ep_loc_newId := first(i_loc_newid);
						
						    for i_id | exists(i_city | 
						                    bp_city_x_id(i_city, i_id) 
						                    and bp_city_x_country(i_city, ep_country)) do
						
						        bp_loc_oldId_x_newId(i_id, ep_loc_newId) :=  1;
						        ep_loc_newId += 1;
						    endfor;    
						    endblock;
						
						    while p_loc_counter < p_maxCities do
						        p_loc_randomNewId := ceil(uniform(val(first(i_loc_newid)), val(last(i_loc_newid))));
						        ep_loc_newId := StringToElement(s_loc_newIds, p_loc_randomNewId, 0);
						        ep_city := first(i_city | exists(i_id |  bp_loc_oldId_x_newId(i_id, ep_loc_newId) and bp_city_x_id(i_city, i_id)));
						
						        sp_loc_cityASCII := first(i_city_ascii | bp_city_x_cityASCII(ep_city, i_city_ascii));
						
						        if ep_country and sp_loc_cityASCII then
						
						            sp_loc_message := 100 * (p_loc_counter/$ p_maxCities) + " % - Fetching: " + sp_loc_cityASCII + " - " + ep_country;
						            webui::SetProgressMessage(sp_loc_message);
						
						            pr_callAPIQuery(sp_loc_cityASCII, ep_country);
						            p_loc_counter += 1;
						        endif;
						
						        if  p_loc_counter > 2000 then
						            return 1;
						        endif;            
						    endwhile; 
						else 
						    raise error "No country with this name";   
						endif;
					}
					Set s_loc_newIds {
						Index: i_loc_newid;
						Parameter: ep_loc_newId;
					}
					StringParameter sp_loc_cityASCII;
					StringParameter sp_loc_message;
					ElementParameter ep_loc_cityCountry {
						Range: s_countries;
					}
					Parameter p_loc_randomNewId;
					Parameter p_loc_counter;
					Parameter p_loc_cardinalityOfCitiesFromCountry {
						InitialData: 1;
					}
					Parameter bp_loc_oldId_x_newId {
						IndexDomain: (i_id,i_loc_newid);
						Range: binary;
					}
				}
				Procedure pr_addByLimit {
					Body: {
						empty ep_country, ep_city;
						
						p_loc_counter:= 0;
						
						while p_loc_counter < p_maxCities do
						    p_loc_randomId := ceil(uniform(val(first(i_id)), val(last(i_id))));
						    ep_id := StringToElement(s_ids, p_loc_randomId, 0);
						
						    ep_city := first(i_city | bp_city_x_id(i_city, ep_id));
						    ep_country := first(i_country | bp_city_x_country(ep_city, i_country));
						
						    sp_loc_cityASCII := first(i_city_ascii | bp_city_x_cityASCII(ep_city, i_city_ascii));
						
						    if ep_country and sp_loc_cityASCII then
						        sp_loc_message := 100 * (p_loc_counter/$ p_maxCities) + " % - Fetching: " + sp_loc_cityASCII + " - " + ep_country;
						        webui::SetProgressMessage(sp_loc_message);
						
						        pr_callAPIQuery(sp_loc_cityASCII, ep_country);
						        p_loc_counter += 1;
						    endif;
						
						    if  p_loc_counter > 2000 then
						        return 1;
						    endif;   
						endwhile;
					}
					Parameter p_loc_counter {
						InitialData: 0;
					}
					Parameter p_loc_randomId;
					StringParameter sp_loc_cityASCII;
					StringParameter sp_loc_message;
				}
				Procedure pr_cleanAllNodes {
					Body: {
						empty API_Inputs;
					}
				}
				Procedure pr_deleteNode {
					Body: {
						empty p_latitude(ep_city);
						empty p_longitude(ep_city);
					}
				}
			}
			Section Heuristic_Page {
				StringParameter sp_def_heuristicPrimaryActions {
					IndexDomain: webui::indexPageActionSpec;
					Definition: data { displaytext : "Run",  icon : "aimms-airplane",  procedure : "pr_runAll",  state : "active" };
				}
				StringParameter sp_def_heuristicSidePanel {
					IndexDomain: (webui::indexPageExtension,webui::indexSidePanelSpec);
					Definition: data { ( 1, displayText ) : "Help",  ( 1, pageId ) : "network_help",  ( 1, icon ) : "aimms-info2",  ( 1, state ) : "active" };
				}
			}
			Section Exact_Page {
				StringParameter sp_def_exactPrimaryActions {
					IndexDomain: webui::indexPageActionSpec;
					Definition: data { displaytext : "Run",  icon : "aimms-airplane",  procedure : "pr_solveModel",  state : "active" };
				}
				StringParameter sp_def_exactSidePanel {
					IndexDomain: (webui::indexPageExtension,webui::indexSidePanelSpec);
					Definition: data { ( 1, displayText ) : "Help",  ( 1, pageId ) : "network_help",  ( 1, icon ) : "aimms-info2",  ( 1, state ) : "active" };
				}
			}
		}
		Section FlagsIdentifier {
			StringParameter sp_readOnlyFlag {
				Definition: "readonly";
			}
		}
	}
	Section Integration {
		Section World_Cities_DB {
			Procedure pr_readWorldCities {
				Body: {
					empty World_Cities_DB;
					read from table db_worldCities;
					
					if exists(i_int_id | sp_int_city(i_int_id)) then
					
					    for i_int_id | sp_int_city(i_int_id) do
					        ep_id := StringToElement(s_ids, val(i_int_id) + 10000, 1); 
					        SetElementAdd(s_cities, ep_city, sp_int_city(i_int_id));
					        SetElementAdd(s_citiesASCII, ep_cityASCII, sp_int_cityASCII(i_int_id));
					        SetElementAdd(s_countries, ep_country, sp_int_country(i_int_id));
					        SetElementAdd(s_provinces, ep_province, sp_int_province(i_int_id));
					
					        sp_countryAcronym(ep_country) := sp_int_countryAcronym(i_int_id);
					
					        bp_city_x_country(ep_city,ep_country) := 1;
					        bp_city_x_cityASCII(ep_city, ep_cityASCII) := 1;
					        bp_city_x_province(ep_city, ep_province) := 1;
					        bp_city_x_id(ep_city, ep_id) := 1;
					    endfor;
					endif;
				}
			}
			StringParameter sp_def_datasource {
				Definition: {
					SQLCreateConnectionString (
					       DatabaseInterface              :  'odbc',
					       DriverName                     :  "SQLite3 ODBC Driver", !Your local drive
					       ServerName                     :  "", 
					       DatabaseName                   :  "WorldCities.db", !The path of your database
					       UserId                         :  "", 
					       Password                       :  "", 
					       AdditionalConnectionParameters :  "");
				}
			}
			DatabaseTable db_worldCities {
				DataSource: sp_def_datasource;
				TableName: "worldCities";
				Mapping: {
					"ID"   -->i_int_id,
					"City" -->sp_int_city,
					"CityASCII" -->sp_int_cityASCII,
					"Country" -->sp_int_country,
					"ISO" -->sp_int_countryAcronym,
					"Province" -->sp_int_province
				}
			}
			Set s_int_id {
				Index: i_int_id;
				Definition: {
					{1..7400}
				}
			}
			StringParameter sp_int_city {
				IndexDomain: i_int_id;
			}
			StringParameter sp_int_cityASCII {
				IndexDomain: i_int_id;
			}
			StringParameter sp_int_country {
				IndexDomain: i_int_id;
			}
			StringParameter sp_int_province {
				IndexDomain: i_int_id;
			}
			StringParameter sp_int_countryAcronym {
				IndexDomain: i_int_id;
			}
		}
		Section LatLong_API {
			StringParameter sp_def_apiKey {
				Definition: "54c8e0e21241f8f235ff0e7329aa989b";
			}
			Procedure pr_callAPIQuery {
				Arguments: (sp_in_city,ep_in_cityCountry);
				Body: {
					!Deleting old info
					if DirectoryExists("out") then
					    DirectoryDelete("out");
					endif;
					DirectoryCreate("out");
					
					block ! fetch query 
					sp_loc_requestId := "fetch" + sp_in_city;
					
					sp_in_city := FindReplaceStrings(sp_in_city, " ", "%20");
					
					sp_loc_urlCall 
					:=  "http://api.positionstack.com/v1/forward?access_key=" + sp_def_apiKey 
					    + "&query=" + sp_in_city 
					    + "&limit=1"
					    + "&country=" + sp_countryAcronym(ep_in_cityCountry);
					
					dex::client::NewRequest(
					        sp_loc_requestId,
					        sp_loc_urlCall,
					        'dex::client::EmptyCallback',
					        responsefile:"out/Output.json",
					        tracefile:"Trace.xml");
					
					dex::client::PerformRequest(sp_loc_requestId);
					dex::client::WaitForResponses(2000);    
					endblock;
					
					delay(5);
					
					pr_readJSONOutput;
				}
				StringParameter sp_in_city {
					Property: Input;
				}
				ElementParameter ep_in_cityCountry {
					Range: s_countries;
					Property: Input;
				}
				StringParameter sp_loc_urlCall;
				StringParameter sp_loc_requestId;
			}
			Section Read_JSON_by_DEX {
				DeclarationSection LatLong {
					dex::Dataset: LatLongDataset;
					dex::TableName: LatLong;
					Set s_int_cities {
						Parameter: ep_int_city;
					}
					Index i_int_city {
						Range: s_int_cities;
						dex::ColumnName: name;
					}
					Parameter p_int_latitude {
						IndexDomain: i_int_city;
						dex::ColumnName: latitude;
					}
					Parameter p_int_longitude {
						IndexDomain: i_int_city;
						dex::ColumnName: longitude;
					}
				}
				Procedure pr_readJSONOutput {
					Body: {
						dex::AddMapping(
							mappingName :  "LatLongMapping", 
							mappingFile :  "Mappings/Generated/LatLongDataset.xml");
						
						dex::ReadFromFile(
							dataFile         :  "out/Output.json", 
							mappingName      :  "LatLongMapping", 
							emptyIdentifiers :  1, 
							emptySets        :  1, 
							resetCounters    :  1);
						
						! Mapping to main data model
						empty ep_city;
						ep_int_city := first(i_int_city);
						sp_loc_city := ep_int_city;
						
						pr_checkReplaceCharacters(sp_loc_city);
						
						ep_city := StringToElement(s_cities, sp_loc_city, 1);
						
						if ep_city then
						    p_latitude(ep_city) := p_int_latitude(ep_int_city);
						    p_longitude(ep_city) := p_int_longitude(ep_int_city);
						else
						    p_def_unableToFetch += 1;
						endif;
					}
					StringParameter sp_loc_city;
				}
			}
		}
	}
	Section Toolkit {
		Procedure pr_checkReplaceCharacters {
			Arguments: (sp_inout_string);
			Body: {
				sp_inout_string := FindReplaceStrings(sp_inout_string, "ã", "a");
				sp_inout_string := FindReplaceStrings(sp_inout_string, "é", "e");
				sp_inout_string := FindReplaceStrings(sp_inout_string, "á", "a");
				sp_inout_string := FindReplaceStrings(sp_inout_string, "õ", "o");
				sp_inout_string := FindReplaceStrings(sp_inout_string, "è", "e");
				sp_inout_string := FindReplaceStrings(sp_inout_string, "í", "i");
				sp_inout_string := FindReplaceStrings(sp_inout_string, "ì", "i");
				sp_inout_string := FindReplaceStrings(sp_inout_string, "ó", "o");
				sp_inout_string := FindReplaceStrings(sp_inout_string, "ò", "o");
				sp_inout_string := FindReplaceStrings(sp_inout_string, "ú", "u");
				sp_inout_string := FindReplaceStrings(sp_inout_string, "ù", "u");
				sp_inout_string := FindReplaceStrings(sp_inout_string, "ñ", "n");
			}
			Comment: "í";
			StringParameter sp_inout_string {
				Property: InOut;
			}
		}
	}
	Procedure MainInitialization {
		Body: {
			empty p_init_tourConnect,p_sim_tourConnect,p_cyc_tourConnect;
			
			p_init_tourInitialized := 0;
			p_sim_initialized  := 0;
			p_cyc_initialized  := 0;
		}
	}
	Procedure PostMainInitialization {
		Body: {
			pr_readWorldCities;
		}
	}
	Procedure MainExecution;
	Procedure PreMainTermination {
		Body: {
			return 1;
		}
	}
	Procedure MainTermination {
		Body: {
			return 1;
		}
		Comment: "We return 1 to make sure AIMMS does not ask to save a case when closing the project";
	}
}
