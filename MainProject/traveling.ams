## ams_version=1.0

Model Main_TravelingSalesman {
	Comment: {
		"This model illustrates some of AIMMS control flow statements by means of the
		traveling salesman 2-opt heuristic. You will find some declarations to define
		the problem, along with
		- a procedure and some declarations to compute and visualize an initial tour
		  constructed by starting at some city and successively selecting the next
		  city as the closest city not yet part of the tour
		- a procedure and some declarations to compute and visualize an improved tour
		  constructed by repetitively swapping those two arcs in the tour by means of
		  the 2-opt heuristic that give the largest overall distance improvement, until
		  no further improvement is possible or the iteration limit is reached
		- a procedure and some declarations to compute and visualize an improved tour
		  constructed by repetitively swapping the next arc in the (modified) tour
		  with that neighbor arc which gives the largest distance improvement, until
		  the iteration limit is reached or a full cycle over the tour gives no
		  further improvement.
		  
		  Keywords:
		  Algorithm, network object, traveling salesman problem, GMP, Progress Window."
	}
	Section Data_Model {
		Section Quantities_and_Units {
			Comment: {
				"This section contains all the units and quantities that are added automatically by AIMMS.
				It is recommended to declare all your quantities here."
			}
			Quantity SI_Time_Duration {
				BaseUnit: s;
				Conversions: {
					century->s : #-># * 3153600000,
					year->s : #-># * 31536000,
					month->s : #-># * 2628000,
					week->s : #-># * 604800,
					day->s : #-># * 86400,
					hour->s : #-># * 3600,
					minute->s : #-># * 60,
					second->s : #-># ,
					tick->s : #-># / 100
				}
				Comment: "Expresses the value for the duration of periods.";
			}
		}
		Section Inputs {
			DeclarationSection DB_Inputs {
				Set s_ids {
					Index: i_id;
					Parameter: ep_id;
				}
				Set s_cities {
					Text: "The set of cities in the tour";
					Index: i_city1, i_city2, i_city;
					Parameter: ep_city;
				}
				Set s_citiesASCII {
					Index: i_city_ascii;
					Parameter: ep_cityASCII;
				}
				Set s_countries {
					Index: i_country;
					Parameter: ep_country;
				}
				Set s_provinces {
					Index: i_province;
					Parameter: ep_province;
				}
				StringParameter sp_countryAcronym {
					IndexDomain: i_country;
				}
				Parameter bp_city_x_country {
					IndexDomain: (i_city,i_country);
				}
				Parameter bp_city_x_id {
					IndexDomain: (i_city,i_id);
				}
				Parameter bp_city_x_cityASCII {
					IndexDomain: (i_city,i_city_ascii);
				}
				Parameter bp_city_x_province {
					IndexDomain: (i_city,i_province);
				}
			}
			DeclarationSection API_Inputs {
				Set s_nodes {
					SubsetOf: s_cities;
					Index: i_node1, i_node2;
					Parameter: ep_node;
					Definition: {
						{i_city | 
						        p_latitude(i_city)
						        and p_longitude(i_city)}
					}
					webui::AnnotationsIdentifier: sp_def_nodeAnnotation;
				}
				Set s_subtours {
					SubsetOf: s_nodes;
				}
				Parameter p_def_cardinalityOfNodes {
					Definition: card(s_nodes);
				}
				Set s_neighbors {
					IndexDomain: i_node1;
					SubsetOf: s_cities;
					Text: "The set of neighbors of city i";
					OrderBy: user;
					Definition: NBest(i_node2 | (i_node1 <> i_node2), -p_def_haversineDistance(i_node1,i_node2), p_def_maxNeighbors);
				}
				Parameter p_maxCities {
					Text: "Maximum number of cities in the tour";
					Range: {
						{-inf..inf}
					}
					Default: 100;
					InitialData: 100;
				}
				Parameter p_latitude {
					IndexDomain: i_city;
					Text: "X-Coordinate of city c";
					InitialData: 0;
				}
				Parameter p_longitude {
					IndexDomain: i_city;
					Text: "Y-Coordinate of city c";
					InitialData: 0;
				}
				Parameter p_def_haversineDistance {
					IndexDomain: (i_node1,i_node2) | i_node1 <> i_node2;
					Text: "Distance from city i to city j";
					Definition: {
						((6371.0 ) 
						*   arccos(
						            cos(radians(90 - P_latitude(i_node1)))
						            * cos(radians(90 - P_latitude(i_node2))) 
						            + 
						            sin(radians(90 - P_latitude(i_node1)))
						            * sin(radians(90 - P_latitude(i_node2)))
						            * cos(radians(p_longitude(i_node1) - p_longitude(i_node2)))))
					}
					Comment: {
						"! Formula also present on http://www.movable-type.co.uk/scripts/latlong.html section Spherical Law of Cosines.
						! calculate distance from haversine formulas"
					}
				}
				Parameter p_def_iterationLimit {
					Text: "Maximum number of iterations to improve tour";
					Definition: {
						floor(card(s_nodes) / 3);
					}
				}
				Parameter p_def_maxNeighbors {
					Text: "Maximum number of neighbors considered for each city";
					Definition: {
						floor(Sqrt(p_maxCities));
					}
				}
			}
		}
		Section Math_Model {
			Section Heuristic {
				Procedure pr_clearSolutions {
					Body: {
						empty p_init_tourconnect, p_sim_tourConnect, p_cyc_tourconnect ;
					}
				}
				Procedure pr_runAll {
					Body: {
						pr_findInitialTour; 
						pr_improveTourCyclic;
						pr_improveTourSimultaneous;
					}
				}
				Section Initial_Tour {
					Comment: {
						"This section contains all declarations and procedures necessary to
						compute and visualize the initial tour."
					}
					Parameter p_init_tourDistance {
						Text: "Total distance of the initial tour";
						webui::FlagsIdentifier: sp_readOnlyFlag;
					}
					Parameter p_init_tourConnect {
						IndexDomain: (i_node1,i_node2);
						Text: "City i connected to city j in initial tour";
						webui::TooltipIdentifier: sp_def_arcTooltip(i_node1,i_node2);
					}
					ElementParameter ep_init_nextCity {
						IndexDomain: i_city;
						Text: "Next city of city c in initial tour";
						Range: s_cities;
					}
					ElementParameter ep_init_prevCity {
						IndexDomain: i_city;
						Text: "Previous city of city c in initial tour";
						Range: s_cities;
					}
					Parameter p_init_tourInitialized {
						Text: "Flag to indicate that an initial tour has been computed for a newly created tour";
					}
					Parameter p_init_timeElapsed {
						Unit: s;
						webui::FlagsIdentifier: sp_readOnlyFlag;
					}
					Procedure pr_findInitialTour {
						Body: {
							empty Initial_Tour, p_init_tourConnect;
							
							stopwatch::pr_start;
							s_loc_remainingCities := s_nodes;
							
							! We start adding the first city to the tour
							ep_node := First(s_nodes);
							s_loc_remainingCities -= ep_node;
							
							! For every other city, the next city in the tour is the one closest to it not yet chosen
							while (Card(s_loc_remainingCities) <> 0) do
							    ep_init_nextCity(ep_node) 
							    :=  argmin(i_node1 in s_loc_remainingCities, p_def_haversineDistance(ep_node,i_node1));
							
							    ep_node := ep_init_nextCity(ep_node);
							    s_loc_remainingCities -= ep_node;
							endwhile;
							
							! Finally, close the tour
							ep_init_nextCity(ep_node) := First(s_nodes);
							
							ep_init_prevCity(ep_init_nextCity(i_node1)) := i_node1;
							p_init_tourConnect(i_node1,ep_init_nextCity(i_node1)) := 1;
							p_init_tourDistance := sum(i_node1, p_def_haversineDistance(i_node1,ep_init_nextCity(i_node1)));
							
							p_init_tourInitialized := 1;
							
							p_init_timeElapsed := stopwatch::fnc_elapsed;
						}
						Comment: {
							"This procedure computes an initial tour by starting at the first city,
							and successively adding the closest remaining city."
						}
						Set s_loc_remainingCities {
							SubsetOf: s_cities;
						}
					}
				}
				Section Improve_Tour_Simultaneous {
					Comment: {
						"This section contains all identifiers and the procedure necessary to compute
						and visualize improved tours using an algorithm that selects the neighbor of a
						city for swapping, considering all cities in the tour simultaneously."
					}
					Set s_sim_nodes {
						SubsetOf: s_nodes;
						Index: i_sim_node, i_sim_node1, i_sim_node2;
						Parameter: ep_sim_node;
						Definition: {
							{i_city | 
							        p_latitude(i_city)
							        and p_longitude(i_city)}
						}
						webui::AnnotationsIdentifier: sp_def_simNodeAnnotation;
					}
					Parameter p_sim_distanceChange {
						IndexDomain: (i_node1,i_node2);
						Text: "Improvement in total tour distance by swapping city i with neighbor j in simultaneous algorithm";
						Default: -inf;
						Definition: p_def_haversineDistance(i_node1,p_sim_nextCity(i_node1)) + p_def_haversineDistance(i_node2,p_sim_nextCity(i_node2)) - (p_def_haversineDistance(i_node1,i_node2) + p_def_haversineDistance(p_sim_nextCity(i_node1),p_sim_nextCity(i_node2)));
					}
					Parameter p_sim_maxChange {
						Text: "Maximum possible distance improvement in simultaneous algorithm";
						Definition: Max((i_node1,i_node2 in s_neighbors(i_node1)), p_sim_distanceChange(i_node1,i_node2));
					}
					Parameter p_sim_swaps {
						Text: "Number of performed swaps in simultaneous algorithm";
					}
					Parameter p_sim_tourDistance {
						Text: "Total tour distance after current iteration in simultaneous algorithm";
						InitialData: 0;
						webui::FlagsIdentifier: sp_readOnlyFlag;
					}
					Parameter p_sim_tourConnect {
						IndexDomain: (i_node1,i_node2);
						Text: "City i connected to city j after current iteration in simultaneous algorithm";
						webui::TooltipIdentifier: sp_def_arcTooltip(i_node1,i_node2);
					}
					ElementParameter p_sim_nextCity {
						IndexDomain: i_city;
						Text: "Next city of city c after current iteration in simultaneous algorithm";
						Range: s_cities;
					}
					ElementParameter p_sim_prevCity {
						IndexDomain: i_city;
						Text: "Previous city of city c after current iteration in simultaneous algorithm";
						Range: s_cities;
					}
					Parameter p_sim_initialized {
						Text: "Flag to indicate that simultaneous algorithm has been initialized";
					}
					Parameter p_sim_uselessLoops;
					Parameter p_sim_timeElapsed {
						Unit: s;
						webui::FlagsIdentifier: sp_readOnlyFlag;
					}
					Procedure pr_improveTourCyclic {
						Body: {
							empty Improve_Tour_Cyclic;
							
							if not p_init_tourInitialized then 
							    pr_findInitialTour; 
							endif;
							
							stopwatch::pr_start;
							if (not p_cyc_initialized) then
							   p_cyc_nextCity(i_node1) := ep_init_nextCity(i_node1);
							   p_cyc_prevCity(i_node1) := ep_init_prevCity(i_node1);
							   p_cyc_initialized := 1;
							   p_cyc_swaps := 0;
							endif;
							
							p_loc_uselessLoops := 0;
							ep_node := First(s_nodes);
							
							while (p_cyc_swaps < p_def_iterationLimit 
							        and p_loc_uselessLoops <= card(s_nodes)) do
							
							    p_loc_uselessLoops += 1;
							
							    ! Select a NewNext to be swapped with City
							    ep_loc_nextCity := argmax(i_node1 in s_neighbors(ep_node), p_cyc_distanceChange(ep_node,i_node1));
							
							    if (p_cyc_distanceChange(ep_node, ep_loc_nextCity) > 0) then
							        p_cyc_swaps += 1;
							        p_loc_uselessLoops := 0;
							
							        block ! Swap cities in tour.
							            ! This is the hairy part of the algorithm. The direction of the tour changes from
							            ! City to NewNext as part of the 2-opt heuristic. To modify the next and previous
							            ! city references we have to walk over the subtour, carefully making sure we don't
							            ! destroy any information while reversing the direction.
							
							            ! Set up a link from the old destinations of City to the old destination of NewNext in the tour
							            ep_loc_OCity := p_cyc_NextCity(ep_node);
							            ep_loc_DCity := p_cyc_nextCity(ep_loc_nextCity);
							            p_cyc_nextCity(ep_loc_OCity) := ep_loc_DCity;
							            p_cyc_prevCity(ep_loc_DCity) := ep_loc_OCity;
							
							            ! Reverse the chain from the old destination of City to NextNew
							            ep_loc_OCity := ep_loc_nextCity;
							            ep_loc_DCity := p_cyc_prevCity(ep_loc_OCity);
							
							            while ( ep_loc_DCity <> ep_node ) do
							                 ep_loc_ODCity := ep_loc_DCity;
							                 p_cyc_NextCity(ep_loc_OCity) := ep_loc_ODCity;
							                 ep_loc_DCity := p_cyc_prevCity(ep_loc_ODCity);
							                 p_cyc_prevCity(ep_loc_ODCity) := ep_loc_OCity;
							                 ep_loc_OCity := ep_loc_ODCity;
							            endwhile;
							
							            ! Finally, setup the link from City to NextNew
							            p_cyc_NextCity(ep_node) := ep_loc_nextCity;
							            p_cyc_PrevCity(ep_loc_nextCity) := ep_node;
							        endblock;
							
							        block ! Update network flow object.
							            empty p_cyc_tourConnect;
							            p_cyc_TourConnect(i_node1,p_cyc_NextCity(i_node1)) := 1;
							            p_cyc_TourDistance := sum(i_node1, p_def_haversineDistance(i_node1,p_cyc_nextCity(i_node1)));
							
							        endblock;
							    endif;
							
							    ep_node := p_cyc_nextCity(ep_node);
							endwhile;
							
							p_sim_timeElapsed := stopwatch::fnc_elapsed;
						}
						Parameter p_loc_uselessLoops {
							Text: "Counter for counting number of iterations without tour improvement";
						}
						ElementParameter ep_loc_nextCity {
							Range: s_cities;
						}
						ElementParameter ep_loc_OCity {
							Range: s_cities;
						}
						ElementParameter ep_loc_DCity {
							Range: s_cities;
						}
						ElementParameter ep_loc_ODCity {
							Range: s_cities;
						}
					}
					Procedure pr_refreshingImproveTourSimultaneous {
						Arguments: (sp_in_userAnswer);
						Body: {
							if sp_in_userAnswer = "Yes" then
							    empty Improve_Tour_Simultaneous;
							
							    block !status bar change
							        sp_statusBar('1', 'icon') := "aimms-circle2";
							        sp_statusBar('1', 'color') := "var(--secondary2)";
							        sp_statusBar('1', 'text') := "Running";
							        sp_statusBar('1', 'tooltip') := "The system is running.";
							        sp_statusBar('1', 'state') := "active";
							    endblock;
							
							    sp_def_simNodeAnnotation(i_city) := "node-running";
							
							    if not p_init_tourInitialized then 
							        pr_findInitialTour; 
							    endif;
							
							    if (not p_sim_initialized) then
							        p_sim_nextCity(i_node1) := ep_init_nextCity(i_node1);
							        p_sim_prevCity(i_node1) := ep_init_prevCity(i_node1);
							        p_sim_initialized := 1;
							        p_sim_swaps := 0;
							    endif;
							
							    p_cyc_uselessLoops := 0;
							    ep_node := First(s_nodes);
							
							    pr_singleIterationImproveTourSimultaneous();
							
							endif;
						}
						ElementParameter ep_loc_nextCity {
							Range: s_cities;
						}
						ElementParameter ep_loc_OCity {
							Range: s_cities;
						}
						ElementParameter ep_loc_DCity {
							Range: s_cities;
						}
						ElementParameter ep_loc_ODCity {
							Range: s_cities;
						}
						StringParameter sp_in_userAnswer {
							Property: Input;
						}
					}
					Procedure pr_singleIterationImproveTourSimultaneous {
						Body: {
							p_sim_uselessLoops += 1;
							
							! Select a ep_loc_nextCity to be swapped with City
							ep_loc_nextCity := argmax(i_node1 in s_neighbors(ep_node), p_sim_distanceChange(ep_node,i_node1));
							
							if (p_sim_distanceChange(ep_node, ep_loc_nextCity) > 0) then
							    p_sim_swaps += 1;
							    p_sim_uselessLoops := 0;
							
							    block ! Swap cities in tour.
							        ! This is the hairy part of the algorithm. The direction of the tour changes from
							        ! City to NewNext as part of the 2-opt heuristic. To modify the next and previous
							        ! city references we have to walk over the subtour, carefully making sure we don't
							        ! destroy any information while reversing the direction.
							
							        ! Set up a link from the old destinations of City to the old destination of NewNext in the tour
							        ep_loc_OCity := p_sim_nextCity(ep_node);
							        ep_loc_DCity := p_sim_nextCity(ep_loc_nextCity);
							        p_sim_nextCity(ep_loc_OCity) := ep_loc_DCity;
							        p_sim_prevCity(ep_loc_DCity) := ep_loc_OCity;
							
							        ! Reverse the chain from the old destination of City to NextNew
							        ep_loc_OCity := ep_loc_nextCity;
							        ep_loc_DCity := p_sim_prevCity(ep_loc_OCity);
							
							        while ( ep_loc_DCity <> ep_node ) do
							            ep_loc_ODCity := ep_loc_DCity;
							            p_sim_nextCity(ep_loc_OCity) := ep_loc_ODCity;
							            ep_loc_DCity := p_sim_prevCity(ep_loc_ODCity);
							            p_sim_prevCity(ep_loc_ODCity) := ep_loc_OCity;
							            ep_loc_OCity := ep_loc_ODCity;
							        endwhile;
							
							        ! Finally, setup the link from City to NextNew
							        p_sim_nextCity(ep_node) := ep_loc_nextCity;
							        p_sim_prevCity(ep_loc_nextCity) := ep_node;
							    endblock; 
							
								block ! Update network flow object.
							        empty p_sim_tourConnect;
							        p_sim_tourConnect(i_node1, p_sim_nextCity(i_node1)) := 1;
							        p_sim_tourDistance := sum(i_node1, p_def_haversineDistance(i_node1, p_sim_nextCity(i_node1)));
								endblock;
							endif;
							
							ep_node := p_sim_nextCity(ep_node);
							
							if p_sim_swaps < p_def_iterationLimit
							    and p_sim_uselessLoops <= card(s_nodes) then
							
								pr_scheduleOver(
									p_in_noSecs   :  1[s], 
									ep_in_payLoad :  'pr_singleIterationImproveTourSimultaneous');
							
							else	        
							    sp_def_simNodeAnnotation(i_city) := "node-done";
							
							    block !status bar change
							        sp_statusBar('1', 'icon') := "aimms-circle2";
							        sp_statusBar('1', 'color') := "var(--secondary)";
							        sp_statusBar('1', 'text') := "Ready";
							        sp_statusBar('1', 'tooltip') := "The run is completed.";
							        sp_statusBar('1', 'state') := "active";
							    endblock;
							endif ;
						}
						ElementParameter ep_loc_nextCity {
							Range: s_cities;
						}
						ElementParameter ep_loc_OCity {
							Range: s_cities;
						}
						ElementParameter ep_loc_DCity {
							Range: s_cities;
						}
						ElementParameter ep_loc_ODCity {
							Range: s_cities;
						}
					}
				}
				Section Improve_Tour_Cyclic {
					Comment: {
						"This section contains all identifiers and the procedure necessary to compute
						and visualize improved tours using an algorithm that selects that neighbor of the
						next city in the (modified) tour for swapping which causes the largest distance
						improvement."
					}
					Set s_cyc_nodes {
						SubsetOf: s_nodes;
						Index: i_cyc_node, i_cyc_node1, i_cyc_node2;
						Parameter: ep_cyc_node;
						Definition: {
							{i_city | 
							        p_latitude(i_city)
							        and p_longitude(i_city)}
						}
						webui::AnnotationsIdentifier: sp_def_cycNodeAnnotation;
					}
					Macro p_cyc_distanceChange {
						Text: "Improvement in total tour distance by swapping city i with neighbor j in cyclic algorithm";
						Arguments: (i_node1,i_node2);
						Definition: p_def_haversineDistance(i_node1,p_cyc_nextCity(i_node1)) + p_def_haversineDistance(i_node2,p_cyc_nextCity(i_node2)) - (p_def_haversineDistance(i_node1,i_node2) + p_def_haversineDistance(p_cyc_nextCity(i_node1),p_cyc_nextCity(i_node2)));
					}
					Parameter p_cyc_swaps {
						Text: "Number of performed swaps in cyclic algorithm";
					}
					Parameter p_cyc_tourDistance {
						Text: "Total tour distance after current iteration in cyclic algorithm";
						InitialData: 0;
						webui::FlagsIdentifier: sp_readOnlyFlag;
					}
					Parameter p_cyc_tourConnect {
						IndexDomain: (i_node1,i_node2);
						Text: "City i connected to city j after current iteration in cyclic algorithm";
						webui::TooltipIdentifier: sp_def_arcTooltip(i_node1,i_node2);
					}
					ElementParameter p_cyc_nextCity {
						IndexDomain: i_city;
						Text: "Next city of city c after current iteration in cyclic algorithm";
						Range: s_cities;
					}
					ElementParameter p_cyc_prevCity {
						IndexDomain: i_city;
						Text: "Previous city of city c after current iteration in cyclic algorithm";
						Range: s_cities;
					}
					Parameter p_cyc_initialized {
						Text: "Flag to indicate that cyclic algorithm has been initialized";
					}
					Parameter p_cyc_uselessLoops;
					Parameter p_cyc_timeElapsed {
						Unit: s;
						webui::FlagsIdentifier: sp_readOnlyFlag;
					}
					Procedure pr_improveTourSimultaneous {
						Body: {
							empty Improve_Tour_Simultaneous;
							
							if not p_init_tourInitialized then 
							    pr_findInitialTour; 
							endif;
							
							stopwatch::pr_start;
							if (not p_sim_initialized) then
							   p_sim_nextCity(i_node1) := ep_init_nextCity(i_node1);
							   p_sim_prevCity(i_node1) := ep_init_prevCity(i_node1);
							   p_sim_initialized := 1;
							   p_sim_swaps := 0;
							endif;
							
							
							while (p_sim_maxChange > 0 and LoopCount <= p_def_iterationLimit) do
							
							    p_sim_swaps += 1;
							
							    ! Select City and NewNext as a (i,j) tuple which reaches the maximum change
							    for ((i_node1,i_node2) | p_sim_distanceChange(i_node1,i_node2) = p_sim_maxChange) do
							        ep_node := i_node1;
							        ep_loc_nextCity := i_node2;
							        break;
							    endfor;
							
							    block ! Swap cities in tour.
							        ! This is the hairy part of the algorithm. The direction of the tour changes from
							        ! City to NewNext as part of the 2-opt heuristic. To modify the next and previous
							        ! city references we have to walk over the subtour, carefully making sure we don't
							        ! destroy any information while reversing the direction.
							
							        ! Set up a link from the old destinations of City to the old destination of NewNext in the tour
							        ep_loc_OCity := p_sim_nextCity(ep_node);
							        ep_loc_DCity := p_sim_nextCity(ep_loc_nextCity);
							        p_sim_nextCity(ep_loc_OCity) := ep_loc_DCity;
							        p_sim_prevCity(ep_loc_DCity) := ep_loc_OCity;
							
							        ! Reverse the chain from the old destination of City to NextNew
							        ep_loc_OCity := ep_loc_nextCity;
							        ep_loc_DCity := p_sim_prevCity(ep_loc_OCity);
							
							        while ( ep_loc_DCity <> ep_node ) do
							            ep_loc_ODCity := ep_loc_DCity;
							            p_sim_nextCity(ep_loc_OCity) := ep_loc_ODCity;
							            ep_loc_DCity := p_sim_prevCity(ep_loc_ODCity);
							            p_sim_prevCity(ep_loc_ODCity) := ep_loc_OCity;
							            ep_loc_OCity := ep_loc_ODCity;
							        endwhile;
							
							        ! Finally, setup the link from City to NextNew
							        p_sim_nextCity(ep_node) := ep_loc_nextCity;
							        p_sim_prevCity(ep_loc_nextCity) := ep_node;
							    endblock; 
							
							    block ! Update network flow object.
							        empty p_sim_tourConnect;
							        p_sim_tourConnect(i_node1, p_sim_nextCity(i_node1)) := 1;
							        p_sim_tourDistance := sum(i_node1, p_def_haversineDistance(i_node1, p_sim_nextCity(i_node1)));
							    endblock;
							
							endwhile;
							
							p_cyc_timeElapsed := stopwatch::fnc_elapsed;
						}
						ElementParameter ep_loc_nextCity {
							Range: s_cities;
						}
						ElementParameter ep_loc_OCity {
							Range: s_cities;
						}
						ElementParameter ep_loc_DCity {
							Range: s_cities;
						}
						ElementParameter ep_loc_ODCity {
							Range: s_cities;
						}
					}
					Procedure pr_refreshingImproveTourCyclic {
						Arguments: (sp_in_userAnswer);
						Body: {
							if sp_in_userAnswer = "Yes" then
							    empty Improve_Tour_Cyclic;
							
							    block !status bar change
							        sp_statusBar('1', 'icon') := "aimms-circle2";
							        sp_statusBar('1', 'color') := "var(--secondary2)";
							        sp_statusBar('1', 'text') := "Running";
							        sp_statusBar('1', 'tooltip') := "The system is running.";
							        sp_statusBar('1', 'state') := "active";
							    endblock;
							
							    sp_def_cycNodeAnnotation(i_city) := "node-running";
							
							
							    if not p_init_tourInitialized then 
							        pr_findInitialTour; 
							    endif;
							
							    if (not p_cyc_initialized) then
							    p_cyc_nextCity(i_node1) := ep_init_nextCity(i_node1);
							    p_cyc_prevCity(i_node1) := ep_init_prevCity(i_node1);
							    p_cyc_initialized := 1;
							    p_cyc_swaps := 0;
							    endif;
							
							    p_cyc_uselessLoops := 0;
							    ep_node := First(s_nodes);
							
							    pr_singleIterationImproveTourCyclic();
							endif;
						}
						ElementParameter ep_loc_nextCity {
							Range: s_cities;
						}
						ElementParameter ep_loc_OCity {
							Range: s_cities;
						}
						ElementParameter ep_loc_DCity {
							Range: s_cities;
						}
						ElementParameter ep_loc_ODCity {
							Range: s_cities;
						}
						StringParameter sp_in_userAnswer {
							Property: Input;
						}
					}
					Procedure pr_singleIterationImproveTourCyclic {
						Body: {
							p_cyc_uselessLoops += 1;
							
							! Select a ep_loc_nextCity to be swapped with City
							ep_loc_nextCity := argmax(i_node1 in s_neighbors(ep_node), p_cyc_distanceChange(ep_node,i_node1));
							
							if (p_cyc_distanceChange(ep_node, ep_loc_nextCity) > 0) then
								p_cyc_swaps += 1;
								p_cyc_uselessLoops := 0;
							
								block ! Swap cities in tour.
									! This is the hairy part of the algorithm. The direction of the tour changes from
									! City to NewNext as part of the 2-opt heuristic. To modify the next and previous
									! city references we have to walk over the subtour, carefully making sure we don't
									! destroy any information while reversing the direction.
							
									! Set up a link from the old destinations of City to the old destination of NewNext in the tour
									ep_loc_OCity := p_cyc_NextCity(ep_node);
									ep_loc_DCity := p_cyc_nextCity(ep_loc_nextCity);
									p_cyc_nextCity(ep_loc_OCity) := ep_loc_DCity;
									p_cyc_prevCity(ep_loc_DCity) := ep_loc_OCity;
							
									! Reverse the chain from the old destination of City to NextNew
									ep_loc_OCity := ep_loc_nextCity;
									ep_loc_DCity := p_cyc_prevCity(ep_loc_OCity);
							
									while ( ep_loc_DCity <> ep_node ) do
										ep_loc_ODCity := ep_loc_DCity;
										p_cyc_NextCity(ep_loc_OCity) := ep_loc_ODCity;
										ep_loc_DCity := p_cyc_prevCity(ep_loc_ODCity);
										p_cyc_prevCity(ep_loc_ODCity) := ep_loc_OCity;
										ep_loc_OCity := ep_loc_ODCity;
									endwhile;
							
									! Finally, setup the link from City to NextNew
									p_cyc_NextCity(ep_node) := ep_loc_nextCity;
									p_cyc_PrevCity(ep_loc_nextCity) := ep_node;
								endblock;
							
								block ! Update network flow object.
									empty p_cyc_tourConnect;
									p_cyc_TourConnect(i_node1,p_cyc_NextCity(i_node1)) := 1;
									p_cyc_TourDistance := sum(i_node1, p_def_haversineDistance(i_node1,p_cyc_nextCity(i_node1)));
								endblock;
							endif;
							
							ep_node := p_cyc_nextCity(ep_node);
							
							if p_cyc_swaps < p_def_iterationLimit
							    and p_cyc_uselessLoops <= card(s_nodes) then
							
								pr_scheduleOver(
									p_in_noSecs   :  1[s], 
									ep_in_payLoad :  'pr_singleIterationImproveTourCyclic');
							else 
							    sp_def_cycNodeAnnotation(i_city) := "node-done";
							
							    block !status bar change
							        sp_statusBar('1', 'icon') := "aimms-circle2";
							        sp_statusBar('1', 'color') := "var(--secondary)";
							        sp_statusBar('1', 'text') := "Ready";
							        sp_statusBar('1', 'tooltip') := "The run is completed.";
							        sp_statusBar('1', 'state') := "active";
							    endblock;
							endif;
						}
						ElementParameter ep_loc_nextCity {
							Range: s_cities;
						}
						ElementParameter ep_loc_OCity {
							Range: s_cities;
						}
						ElementParameter ep_loc_DCity {
							Range: s_cities;
						}
						ElementParameter ep_loc_ODCity {
							Range: s_cities;
						}
					}
				}
			}
			Section Exact {
				Set s_TSPConstraints {
					SubsetOf: AllConstraints;
					Definition: AllConstraints - data { 'c_subtourElimination' };
				}
				MathematicalProgram mp_TSP {
					Objective: v_objective;
					Direction: minimize;
					Constraints: s_TSPConstraints;
					Variables: AllVariables;
					Type: ep_modelType;
				}
				Variable v_objective {
					Range: free;
					Definition: sum( (i_node1,i_node2), p_def_haversineDistance(i_node1,i_node2) * v_networkTour(i_node1,i_node2) );
				}
				Variable v_networkTour {
					IndexDomain: (i_node1,i_node2) | i_node1 > i_node2;
					Range: binary;
				}
				Constraint c_subtourElimination {
					Definition: {
						sum((i_node1,i_node2) | 
						        i_node1 in s_subtours 
						        and not i_node2 in s_subtours, 
						    v_networkTour(i_node1,i_node2) 
						    + v_networkTour(i_node2,i_node1)) 
						>= 2
					}
				}
				Constraint c_degreeCheck {
					IndexDomain: i_node2;
					Definition: {
						sum(i_node1, 
						    v_networkTour(i_node1,i_node2) 
						    + v_networkTour(i_node2,i_node1)) 
						= 2
					}
				}
				ElementParameter ep_GMP {
					Range: AllGeneratedMathematicalPrograms;
				}
				Parameter p_calc_solutionTour {
					IndexDomain: (i_node1,i_node2);
				}
				Parameter bp_showSolutionWithSubtours {
					Text: "Show incumbents with subtours";
					Range: binary;
					Property: NoSave;
					InitialData: 1;
				}
				Parameter p_exactObjective {
					webui::FlagsIdentifier: sp_readOnlyFlag;
				}
				ElementParameter ep_modelType {
					Range: AllMathematicalProgrammingTypes;
				}
				Parameter p_exactTimeElapsed {
					Unit: s;
					webui::FlagsIdentifier: sp_readOnlyFlag;
				}
				Procedure pr_callbackLazy {
					Arguments: ep_in_thisSession;
					Body: {
						! Retrieve solution from solver session and send it to the AIMMS variables.
						GMP::Solution::RetrieveFromSolverSession(ep_in_thisSession, 1);
						GMP::Solution::SendToModelSelection(ep_GMP, 1, AllVariables, Suffices);
						
						pr_determineSubtours(ep_in_thisSession);
						
						return 1;
					}
					ElementParameter ep_in_thisSession {
						Range: AllSolverSessions;
						Property: Input;
					}
					Set Suffices {
						SubsetOf: AllSuffixNames;
						InitialData: data { 'Level' };
					}
				}
				Procedure pr_determineSubtours {
					Arguments: ep_in_thisSession;
					Body: {
						empty s_subtours, p_loc_foundSubtour;
						
						s_loc_remainingCities := s_nodes;
						
						! We start adding the first city to the tour.
						ep_loc_firstCity := First(s_loc_remainingCities);
						ep_loc_city := ep_loc_firstCity;
						s_loc_remainingCities -= ep_loc_city;
						s_subtours := ep_loc_city;
						
						while Card(s_loc_remainingCities) > 0 do
							! For every other city, the next city in the tour is the one closest to it not yet chosen.
						    ep_loc_initNextCity(ep_loc_city) 
						    :=  argmax(i_city in s_loc_remainingCities, 
						            v_networkTour(ep_loc_city, i_city) 
						            + v_networkTour(i_city, ep_loc_city));
						
						    if (v_networkTour(ep_loc_city, ep_loc_initNextCity(ep_loc_city)) + v_networkTour(ep_loc_initNextCity(ep_loc_city), ep_loc_city) > 0.5) then
						    	! Add city to current (sub)tour.
						    	ep_loc_city := ep_loc_initNextCity(ep_loc_city);
						    	s_loc_remainingCities -= ep_loc_city;
						    	s_subtours += ep_loc_city;
						    else
						    	! Close the (sub)tour.
						    	ep_loc_initNextCity(ep_loc_city) := ep_loc_firstCity;
						
						    	if Card(s_subtours) < Card(s_nodes) then
						    		! Add lazy constraints that forbid the subtour just found.
									GMP::SolverSession::GenerateCut(ep_in_thisSession, c_subtourElimination);
									p_loc_foundSubtour := 1;
								endif;
						
								! Start next subtour by adding the first remaining city.
						    	ep_loc_firstCity := First(s_loc_remainingCities);
								ep_loc_city := ep_loc_firstCity;
								s_loc_remainingCities -= ep_loc_city;
								s_subtours := ep_loc_city;
						    endif;
						endwhile;
						
						! Finally, close the last subtour.
						ep_loc_initNextCity(ep_loc_city) := ep_loc_firstCity;
						
						if Card(s_subtours) < Card(s_nodes) then
							! Add lazy constraints that forbid the last subtour.
							GMP::SolverSession::GenerateCut(ep_in_thisSession, c_subtourElimination);
							p_loc_foundSubtour := 1;
						endif;
						
						! Determine tour to display on page.
						if not p_loc_foundSubtour 
						    or bp_showSolutionWithSubtours then
						
							empty p_calc_solutionTour;
							p_calc_solutionTour(i_city, ep_loc_initNextCity(i_city)) := 1;
						endif;
					}
					Comment: {
						"This lazy constraint callback is called whenever the solver finds a new candidate incumbent
						solution. It checks whether the incumbent solution found by the solver contains subtours.
						If yes, then subtour elimination constraints are added, using GMP::SolverSession::GenerateCut,
						that forbid these subtours. If not, then the incumbent solution forms a true solution of the
						TSP problem, as it contains only one tour."
					}
					Set s_loc_remainingCities {
						SubsetOf: s_nodes;
					}
					ElementParameter ep_in_thisSession {
						Range: AllSolverSessions;
						Property: Input;
					}
					ElementParameter ep_loc_city {
						Range: s_nodes;
					}
					ElementParameter ep_loc_firstCity {
						Range: s_nodes;
					}
					ElementParameter ep_loc_initNextCity {
						IndexDomain: i_city;
						Range: s_nodes;
					}
					Parameter p_loc_foundSubtour {
						Range: binary;
					}
				}
				Procedure pr_emptyExactSolution {
					Body: {
						empty v_networkTour, p_calc_solutionTour;
						
						MonitoredIdentifiers := AllIdentifiers;
						
						DataChangeMonitorReset(DataManagementMonitorID, MonitoredIdentifiers);
					}
					Comment: {
						"To avoid a dialog that will ask the user to save the case if the \'Select instance\'
						button is pressed."
					}
					Set MonitoredIdentifiers {
						SubsetOf: AllIdentifiers;
					}
				}
				Procedure pr_solveModel {
					Body: {
						empty Exact;
						
						stopwatch::pr_start;
						ep_modelType := 'MIP';
						ep_GMP := GMP::Instance::Generate(mp_TSP);
						
						GMP::Instance::SetCallbackAddLazyConstraint(ep_GMP, 'pr_callbackLazy');
						GMP::Instance::Solve(ep_GMP);
						
						if GMP::Solution::Count(ep_GMP) >= 1 then
							pr_determineSubtours('');
						endif;
						
						p_exactObjective := v_objective;
						p_exactTimeElapsed := stopwatch::fnc_elapsed;
						
						GMP::Instance::Delete(ep_GMP);
						
						pr_solveRelaxedModel;
					}
				}
				Section Lower_Bound {
					Parameter p_relaxedTourSolution {
						IndexDomain: (i_node1,i_node2);
					}
					Parameter p_lowerBound {
						webui::FlagsIdentifier: sp_readOnlyFlag;
					}
					Parameter p_relaxedTimeElapsed {
						Unit: s;
						webui::FlagsIdentifier: sp_readOnlyFlag;
					}
					Procedure pr_solveRelaxedModel {
						Body: {
							empty Lower_Bound;
							
							stopwatch::pr_start;
							ep_modelType := 'MIP';
							ep_GMP := GMP::Instance::Generate(mp_TSP);
							
							GMP::Instance::Solve(ep_GMP);
							
							p_relaxedTourSolution(i_node1, i_node2) := v_networkTour(i_node1,i_node2);
							p_lowerBound := v_objective;
							p_relaxedTimeElapsed := stopwatch::fnc_elapsed;
						}
					}
				}
			}
		}
	}
	Section UI_Declarations {
		StringParameter sp_logo {
			InitialData: "aimms_logo.png";
		}
		StringParameter sp_statusBar {
			IndexDomain: (webui::indexApplicationExtension,webui::indexStatusBarSpec);
			Comment: {
				"data 
				{  ( 1, icon      ) : \"aimms-circle2\",  ( 1, color     ) : \"orange\",  ( 1, text      ) : \"active\",
				  ( 1, tooltip   ) : \"active\",  ( 1, state     ) : \"active\" }"
			}
		}
		Section Workflow {
			StringParameter sp_myWorkflows {
				IndexDomain: (webui::indexWorkflowOrder,webui::indexWorkflowSpec);
			}
			StringParameter sp_myWorkflowSteps {
				IndexDomain: (webui::indexWorkflowOrder,webui::indexNoOfPages,webui::indexWorkflowPageSpec);
				Definition: {
					data 
					{ ( 1, 1, displayText       ) : "Welcome"             ,  ( 1, 1, icon              ) : "aimms-happy"         ,
					  ( 1, 1, pageId            ) : "home"                ,  ( 1, 1, tooltip           ) : "Welcome"             ,
					  ( 1, 1, workflowPageState ) : "active"              ,  ( 1, 1, pageDataState     ) : "Incomplete"          ,
					  ( 1, 1, redirectPageId    ) : "home"                ,  ( 1, 2, displayText       ) : "Story"               ,
					  ( 1, 2, icon              ) : "aimms-lamp5"         ,  ( 1, 2, pageId            ) : "story"               ,
					  ( 1, 2, tooltip           ) : "Problem description" ,  ( 1, 2, workflowPageState ) : "active"              ,
					  ( 1, 2, pageDataState     ) : "Incomplete"          ,  ( 1, 2, redirectPageId    ) : "home"                ,
					  ( 1, 3, displayText       ) : "Network"             ,  ( 1, 3, icon              ) : "aimms-map"           ,
					  ( 1, 3, pageId            ) : "network"             ,  ( 1, 3, tooltip           ) : "Building the network",
					  ( 1, 3, workflowPageState ) : "active"              ,  ( 1, 3, pageDataState     ) : "Incomplete"          ,
					  ( 1, 3, redirectPageId    ) : "home"                ,  ( 1, 4, displayText       ) : "Heuristic"           ,
					  ( 1, 4, icon              ) : "aimms-finish"        ,  ( 1, 4, pageId            ) : "tours"               ,
					  ( 1, 4, tooltip           ) : "Heuristic tours"     ,  ( 1, 4, workflowPageState ) : "active"              ,
					  ( 1, 4, pageDataState     ) : "Incomplete"          ,  ( 1, 4, redirectPageId    ) : "home"                ,
					  ( 1, 5, displayText       ) : "Exact"               ,  ( 1, 5, icon              ) : "aimms-target"        ,
					  ( 1, 5, pageId            ) : "exact"               ,  ( 1, 5, tooltip           ) : "Exact tour"          ,
					  ( 1, 5, workflowPageState ) : "active"              ,  ( 1, 5, pageDataState     ) : "Incomplete"          ,
					  ( 1, 5, redirectPageId    ) : "home"                ,  ( 1, 6, displayText       ) : "Comparison"          ,
					  ( 1, 6, icon              ) : "aimms-trophy3"       ,  ( 1, 6, pageId            ) : "comparison"          ,
					  ( 1, 6, tooltip           ) : "Tour comparisons"    ,  ( 1, 6, workflowPageState ) : "active"              ,
					  ( 1, 6, pageDataState     ) : "Incomplete"          ,  ( 1, 6, redirectPageId    ) : "home"                 }
				}
			}
		}
		Section Pages {
			Section Network_Page {
				StringParameter sp_mapTitle {
					Definition: {
						"The network has " + card(s_nodes) + " nodes.";
					}
				}
				StringParameter sp_addThisCity {
					InitialData: "";
				}
				StringParameter sp_addByCountry {
					InitialData: "";
				}
				Parameter p_def_unableToFetch {
					InitialData: 0;
					webui::FlagsIdentifier: sp_readOnlyFlag;
				}
				StringParameter sp_def_nodeTooltip {
					IndexDomain: i_city | exists(i_node1 | i_node1 = i_city) or exists(i_node2 | i_node2 = i_city);
					Definition: {
						"<p style=\"text-align: left;\"><em>" + i_city + "</em></p>" +
						"<p style=\"text-align: left;\"><strong>Latitude: </strong>" + p_latitude(i_city) + "</p>" +
						"<p style=\"text-align: left;\"><strong>Longitude: </strong>" + p_longitude(i_city) + "</p>"
					}
				}
				Parameter p_def_nodeSize {
					IndexDomain: i_city;
					Definition: 2;
					webui::TooltipIdentifier: sp_def_nodeTooltip(i_city);
				}
				StringParameter sp_def_arcTooltip {
					IndexDomain: (i_node1,i_node2) | i_node1 <> i_node2;
					Definition: {
						"<p style=\"text-align: left;\">From <em>" + i_node1 + "</em> to <em>" + i_node2 + "</em>.</p>"
					}
				}
				StringParameter sp_def_nodeAnnotation {
					IndexDomain: i_city;
					Definition: "node-done";
				}
				StringParameter sp_def_nodeItemActions {
					IndexDomain: (webui::indexWidgetItemActionSpec,webui::indexPageExtension,webui::indexWidgetActionSpec);
					Definition: {
						data 
						{ ( p_def_nodeSize, 1, displaytext ) : "Delete this node"  ,  ( p_def_nodeSize, 1, icon        ) : "aimms-cross" ,
						  ( p_def_nodeSize, 1, procedure   ) : "pr_deleteNode"  ,  ( p_def_nodeSize, 1, state       ) : "active" }
					}
				}
				StringParameter sp_def_networkSidePanel {
					IndexDomain: (webui::indexPageExtension,webui::indexSidePanelSpec);
					Definition: data { ( 1, displayText ) : "Help",  ( 1, pageId ) : "network_help",  ( 1, icon ) : "aimms-info2",  ( 1, state ) : "active" };
				}
				StringParameter sp_def_addThisCityTooltipButton {
					Definition: "Fetch " + sp_addThisCity + "'s latitude and longitude on PositionStack api.";
				}
				StringParameter p_def_addThisCountryTooltipButton {
					Definition: "Fetch " + p_maxCities + " random cities' latitude and longitude from " + sp_addByCountry + " on PositionStack api.";
				}
				StringParameter sp_def_addByLimitTooltipButton {
					Definition: "Fetch " + p_maxCities + " random cities' latitude and longitude on PositionStack api.";
				}
				Procedure pr_addThisCity {
					Body: {
						if sp_def_apikey = "" then
						    raise error "No api selected";   
						    return;
						endif;   
						
						ep_city := StringToElement(s_cities, sp_addThisCity, 0);
						sp_loc_cityASCII := first(i_city_ascii | bp_city_x_cityASCII(ep_city, i_city_ascii));
						ep_loc_cityCountry := first(i_country | bp_city_x_country(ep_city, i_country));
						
						if ep_loc_cityCountry then
						    pr_callAPIQuery(sp_loc_cityASCII, ep_loc_cityCountry);
						else
						    raise error "No city with this name";   
						endif;
					}
					ElementParameter ep_loc_cityCountry {
						Range: s_countries;
					}
					StringParameter sp_loc_cityASCII;
				}
				Procedure pr_addByCountry {
					Body: {
						if sp_def_apikey = "" then
						    raise error "No api selected";   
						    return;
						endif;   
						
						empty ep_country;
						
						ep_country := StringToElement(s_countries, sp_addByCountry, 0);
						p_loc_counter := 0;
						
						if sp_addByCountry and ep_country then
						    block 
						    p_loc_cardinalityOfCitiesFromCountry  
						    :=  sum(i_id | exists(i_city | 
						                    bp_city_x_id(i_city, i_id) 
						                    and bp_city_x_country(i_city, ep_country)), 1);
						
						    s_loc_newIds := {1 .. p_loc_cardinalityOfCitiesFromCountry};
						    ep_loc_newId := first(i_loc_newid);
						
						    for i_id | exists(i_city | 
						                    bp_city_x_id(i_city, i_id) 
						                    and bp_city_x_country(i_city, ep_country)) do
						
						        bp_loc_oldId_x_newId(i_id, ep_loc_newId) :=  1;
						        ep_loc_newId += 1;
						    endfor;    
						    endblock;
						
						    while p_loc_counter < p_maxCities do
						        p_loc_randomNewId := ceil(uniform(val(first(i_loc_newid)), val(last(i_loc_newid))));
						        ep_loc_newId := StringToElement(s_loc_newIds, p_loc_randomNewId, 0);
						        ep_city := first(i_city | exists(i_id |  bp_loc_oldId_x_newId(i_id, ep_loc_newId) and bp_city_x_id(i_city, i_id)));
						
						        sp_loc_cityASCII := first(i_city_ascii | bp_city_x_cityASCII(ep_city, i_city_ascii));
						
						        if ep_country and sp_loc_cityASCII then
						
						            sp_loc_message := 100 * (p_loc_counter/$ p_maxCities) + " % - Fetching: " + sp_loc_cityASCII + " - " + ep_country;
						            webui::SetProgressMessage(sp_loc_message);
						
						            pr_callAPIQuery(sp_loc_cityASCII, ep_country);
						            p_loc_counter += 1;
						        endif;
						
						        if  p_loc_counter > 2000 then
						            return 1;
						        endif;            
						    endwhile; 
						else 
						    raise error "No country with this name";   
						endif;
					}
					Set s_loc_newIds {
						Index: i_loc_newid;
						Parameter: ep_loc_newId;
					}
					StringParameter sp_loc_cityASCII;
					StringParameter sp_loc_message;
					ElementParameter ep_loc_cityCountry {
						Range: s_countries;
					}
					Parameter p_loc_randomNewId;
					Parameter p_loc_counter;
					Parameter p_loc_cardinalityOfCitiesFromCountry {
						InitialData: 1;
					}
					Parameter bp_loc_oldId_x_newId {
						IndexDomain: (i_id,i_loc_newid);
						Range: binary;
					}
				}
				Procedure pr_addByLimit {
					Body: {
						if sp_def_apikey = "" then
						    raise error "No api selected";   
						    return;
						endif;   
						
						empty ep_country, ep_city;
						
						p_loc_counter:= 0;
						
						while p_loc_counter < p_maxCities do
						    p_loc_randomId := ceil(uniform(val(first(i_id)), val(last(i_id))));
						    ep_id := StringToElement(s_ids, p_loc_randomId, 0);
						
						    ep_city := first(i_city | bp_city_x_id(i_city, ep_id));
						    ep_country := first(i_country | bp_city_x_country(ep_city, i_country));
						
						    sp_loc_cityASCII := first(i_city_ascii | bp_city_x_cityASCII(ep_city, i_city_ascii));
						
						    if ep_country and sp_loc_cityASCII then
						        sp_loc_message := 100 * (p_loc_counter/$ p_maxCities) + " % - Fetching: " + sp_loc_cityASCII + " - " + ep_country;
						        webui::SetProgressMessage(sp_loc_message);
						
						        pr_callAPIQuery(sp_loc_cityASCII, ep_country);
						        p_loc_counter += 1;
						    endif;
						
						    if  p_loc_counter > 2000 then
						        return 1;
						    endif;   
						endwhile;
					}
					Parameter p_loc_counter {
						InitialData: 0;
					}
					Parameter p_loc_randomId;
					StringParameter sp_loc_cityASCII;
					StringParameter sp_loc_message;
				}
				Procedure pr_cleanAllNodes {
					Body: {
						empty API_Inputs;
						pr_clearSolutions;
					}
				}
				Procedure pr_deleteNode {
					Body: {
						empty p_latitude(ep_city);
						empty p_longitude(ep_city);
					}
				}
			}
			Section Heuristic_Page {
				StringParameter sp_def_heuristicPrimaryActions {
					IndexDomain: webui::indexPageActionSpec;
					Definition: data { displaytext : "Run",  icon : "aimms-airplane",  procedure : "pr_runAll",  state : "active" };
				}
				StringParameter sp_def_heuristicSecondaryActions {
					IndexDomain: (webui::indexPageExtension,webui::indexPageActionSpec);
					Definition: {
						data { 
							( 1, displaytext ) : "clear solutions",  
							( 1, icon        ) : "aimms-broom",  
							( 1, procedure   ) : "pr_clearSolutions",  
							( 1, state       ) : "active", 
						
							( 2, displaytext ) : "Initial solution",  
							( 2, icon        ) : "aimms-bucket",  
							( 2, procedure   ) : "pr_findInitialTour",  
							( 2, state       ) : "active", 
						
							( 3, displaytext ) : "Improved Simultaneous",  
							( 3, icon        ) : "aimms-paint-format",  
							( 3, procedure   ) : "pr_checkIterativeSimultaneous",  
							( 3, state       ) : "active", 
						
							( 4, displaytext ) : "Improved Cyclic",  
							( 4, icon        ) : "aimms-brush",  
							( 4, procedure   ) : "pr_checkIterativeCyclic",  
							( 4, state       ) : "active"
						}
					}
				}
				StringParameter sp_def_heuristicSidePanel {
					IndexDomain: (webui::indexPageExtension,webui::indexSidePanelSpec);
					Definition: data { ( 1, displayText ) : "Help",  ( 1, pageId ) : "heuristic_help",  ( 1, icon ) : "aimms-info2",  ( 1, state ) : "active" };
				}
				StringParameter sp_def_simNodeAnnotation {
					IndexDomain: i_city;
					InitialData: "node-done";
				}
				StringParameter sp_def_cycNodeAnnotation {
					IndexDomain: i_city;
					InitialData: "node-done";
				}
				StringParameter sp_titleImprovedTourCyclic {
					InitialData: "Improved Tour (Cyclic)";
				}
				Procedure pr_checkIterativeCyclic {
					Body: {
						s_loc_actions := {'No!', 'Yes'};
						
						webui::RequestPerformWebUIDialog(
							title   :  "Good to know", 
							message :  "This procedure can take a while but you will see the map changing connections. \nDo you want to proceed?", 
							actions :  s_loc_actions, 
							onDone  :  'pr_refreshingImproveTourCyclic');
					}
					Set s_loc_actions;
				}
				Procedure pr_checkIterativeSimultaneous {
					Body: {
						s_loc_actions := {'No!', 'Yes'};
						
						webui::RequestPerformWebUIDialog(
							title   :  "Good to know", 
							message :  "This procedure can take a while but you will see the map changing connections. \nDo you want to proceed?", 
							actions :  s_loc_actions, 
							onDone  :  'pr_refreshingImproveTourSimultaneous');
					}
					Set s_loc_actions;
				}
			}
			Section Exact_Page {
				StringParameter sp_def_exactPrimaryActions {
					IndexDomain: webui::indexPageActionSpec;
					Definition: data { displaytext : "Run",  icon : "aimms-airplane",  procedure : "pr_solveModel",  state : "active" };
				}
				StringParameter sp_def_exactSidePanel {
					IndexDomain: (webui::indexPageExtension,webui::indexSidePanelSpec);
					Definition: data { ( 1, displayText ) : "Help",  ( 1, pageId ) : "exact_help",  ( 1, icon ) : "aimms-info2",  ( 1, state ) : "active" };
				}
			}
		}
		Section FlagsIdentifier {
			StringParameter sp_readOnlyFlag {
				Definition: "readonly";
			}
		}
	}
	Section Integration {
		Section World_Cities_DB {
			Procedure pr_readWorldCities {
				Body: {
					empty World_Cities_DB;
					read from table db_worldCities;
					
					if exists(i_int_id | sp_int_city(i_int_id)) then
					
					    for i_int_id | sp_int_city(i_int_id) do
					        ep_id := StringToElement(s_ids, val(i_int_id) + 10000, 1); 
					        SetElementAdd(s_cities, ep_city, sp_int_city(i_int_id));
					        SetElementAdd(s_citiesASCII, ep_cityASCII, sp_int_cityASCII(i_int_id));
					        SetElementAdd(s_countries, ep_country, sp_int_country(i_int_id));
					        SetElementAdd(s_provinces, ep_province, sp_int_province(i_int_id));
					
					        sp_countryAcronym(ep_country) := sp_int_countryAcronym(i_int_id);
					
					        bp_city_x_country(ep_city,ep_country) := 1;
					        bp_city_x_cityASCII(ep_city, ep_cityASCII) := 1;
					        bp_city_x_province(ep_city, ep_province) := 1;
					        bp_city_x_id(ep_city, ep_id) := 1;
					    endfor;
					endif;
				}
			}
			StringParameter sp_def_datasource {
				Definition: {
					SQLCreateConnectionString (
					       DatabaseInterface              :  'odbc',
					       DriverName                     :  "SQLite3 ODBC Driver", !Your local drive
					       ServerName                     :  "", 
					       DatabaseName                   :  "WorldCities.db", !The path of your database
					       UserId                         :  "", 
					       Password                       :  "", 
					       AdditionalConnectionParameters :  "");
				}
			}
			DatabaseTable db_worldCities {
				DataSource: sp_def_datasource;
				TableName: "worldCities";
				Mapping: {
					"ID"   -->i_int_id,
					"City" -->sp_int_city,
					"CityASCII" -->sp_int_cityASCII,
					"Country" -->sp_int_country,
					"ISO" -->sp_int_countryAcronym,
					"Province" -->sp_int_province
				}
			}
			Set s_int_id {
				Index: i_int_id;
				Definition: {
					{1..7400}
				}
			}
			StringParameter sp_int_city {
				IndexDomain: i_int_id;
			}
			StringParameter sp_int_cityASCII {
				IndexDomain: i_int_id;
			}
			StringParameter sp_int_country {
				IndexDomain: i_int_id;
			}
			StringParameter sp_int_province {
				IndexDomain: i_int_id;
			}
			StringParameter sp_int_countryAcronym {
				IndexDomain: i_int_id;
			}
		}
		Section LatLong_API {
			StringParameter sp_def_apiKey {
				Definition: "";
				Comment: "add api key here";
			}
			Procedure pr_callAPIQuery {
				Arguments: (sp_in_city,ep_in_cityCountry);
				Body: {
					!Deleting old info
					if DirectoryExists("out") then
					    DirectoryDelete("out");
					endif;
					DirectoryCreate("out");
					
					block ! fetch query 
					sp_loc_requestId := "fetch" + sp_in_city;
					
					sp_in_city := FindReplaceStrings(sp_in_city, " ", "%20");
					
					sp_loc_urlCall 
					:=  "http://api.positionstack.com/v1/forward?access_key=" + sp_def_apiKey 
					    + "&query=" + sp_in_city 
					    + "&limit=1"
					    + "&country=" + sp_countryAcronym(ep_in_cityCountry);
					
					dex::client::NewRequest(
					        sp_loc_requestId,
					        sp_loc_urlCall,
					        'dex::client::EmptyCallback',
					        responsefile:"out/Output.json",
					        tracefile:"Trace.xml");
					
					dex::client::PerformRequest(sp_loc_requestId);
					dex::client::WaitForResponses(2000);    
					endblock;
					
					delay(5);
					
					pr_readJSONOutput;
				}
				StringParameter sp_in_city {
					Property: Input;
				}
				ElementParameter ep_in_cityCountry {
					Range: s_countries;
					Property: Input;
				}
				StringParameter sp_loc_urlCall;
				StringParameter sp_loc_requestId;
			}
			Section Read_JSON_by_DEX {
				DeclarationSection LatLong {
					dex::Dataset: LatLongDataset;
					dex::TableName: LatLong;
					Set s_int_cities {
						Parameter: ep_int_city;
					}
					Index i_int_city {
						Range: s_int_cities;
						dex::ColumnName: name;
					}
					Parameter p_int_latitude {
						IndexDomain: i_int_city;
						dex::ColumnName: latitude;
					}
					Parameter p_int_longitude {
						IndexDomain: i_int_city;
						dex::ColumnName: longitude;
					}
				}
				Procedure pr_readJSONOutput {
					Body: {
						dex::AddMapping(
							mappingName :  "LatLongMapping", 
							mappingFile :  "Mappings/Generated/LatLongDataset.xml");
						
						dex::ReadFromFile(
							dataFile         :  "out/Output.json", 
							mappingName      :  "LatLongMapping", 
							emptyIdentifiers :  1, 
							emptySets        :  1, 
							resetCounters    :  1);
						
						! Mapping to main data model
						empty ep_city;
						ep_int_city := first(i_int_city);
						sp_loc_city := ep_int_city;
						
						pr_checkReplaceCharacters(sp_loc_city);
						
						ep_city := StringToElement(s_cities, sp_loc_city, 1);
						
						if ep_city then
						    p_latitude(ep_city) := p_int_latitude(ep_int_city);
						    p_longitude(ep_city) := p_int_longitude(ep_int_city);
						    sp_def_cycNodeAnnotation(ep_city) := "node-done";
						    sp_def_simNodeAnnotation(ep_city) := "node-done";
						
						else
						    p_def_unableToFetch += 1;
						endif;
					}
					StringParameter sp_loc_city;
				}
			}
		}
	}
	Section Toolkit {
		Procedure pr_checkReplaceCharacters {
			Arguments: (sp_inout_string);
			Body: {
				sp_inout_string := FindReplaceStrings(sp_inout_string, "ã", "a");
				sp_inout_string := FindReplaceStrings(sp_inout_string, "é", "e");
				sp_inout_string := FindReplaceStrings(sp_inout_string, "á", "a");
				sp_inout_string := FindReplaceStrings(sp_inout_string, "õ", "o");
				sp_inout_string := FindReplaceStrings(sp_inout_string, "è", "e");
				sp_inout_string := FindReplaceStrings(sp_inout_string, "í", "i");
				sp_inout_string := FindReplaceStrings(sp_inout_string, "ì", "i");
				sp_inout_string := FindReplaceStrings(sp_inout_string, "ó", "o");
				sp_inout_string := FindReplaceStrings(sp_inout_string, "ò", "o");
				sp_inout_string := FindReplaceStrings(sp_inout_string, "ú", "u");
				sp_inout_string := FindReplaceStrings(sp_inout_string, "ù", "u");
				sp_inout_string := FindReplaceStrings(sp_inout_string, "ñ", "n");
			}
			Comment: "í";
			StringParameter sp_inout_string {
				Property: InOut;
			}
		}
		Procedure pr_scheduleOver {
			Arguments: (p_in_noSecs,ep_in_payLoad);
			Body: {
				block ! Sanity checks 
					if p_in_noSecs <= 0[s] then
						raise error 
							formatString("pr_scheduleOver(%n,%e): The number of seconds should be strictly positive.", 
								p_in_noSecs, ep_in_payLoad);
					endif ;
					if not ep_in_payLoad then
						raise error 
							formatString("pr_scheduleOver(%n,%e): Empty payload specified.", 
								p_in_noSecs, ep_in_payLoad);
					endif ;
				endblock ;
				
				block ! Is reference date base on UTC?
					p_loc_ogv 
					:=  OptionGetValue(
				            OptionName :  "use_UTC_forCaseAndStartEndDate", 
				            Lower      :  p_loc_low, 
				            Current    :  p_loc_scheduleAtUsesUTC, 
				            Default    :  p_loc_def, 
				            Upper      :  p_loc_lupp);
				
					if not p_loc_ogv then ! Option use_UTC_forCaseAndStartEndDate is introduced with AIMMS 4.75.
						p_loc_scheduleAtUsesUTC := 0 ; ! Assume option use_UTC_forCaseAndStartEndDate is off.
					endif ;
				endblock ;
				
				sp_loc_refDate := "2023-01-01 00:00:00" ;
				
				p_loc_tmpSec := CurrentToMoment([s], sp_loc_refDate) ;
				p_loc_tmpSec += p_in_noSecs ;
				
				if p_loc_scheduleAtUsesUTC then
					sp_loc_launchDate := MomentToString( "%c%y-%m-%d %H:%M:%S%TZ('UTC')", [s], sp_loc_refDate, p_loc_tmpSec );
				else
					sp_loc_launchDate := MomentToString( "%c%y-%m-%d %H:%M:%S", [s], sp_loc_refDate, p_loc_tmpSec );
				endif ;
				
				! Nb ScheduleAt is precise up to a second.
				if not ScheduleAt(sp_loc_launchDate, ep_in_payLoad) then
				    raise error "Error scheduling procedure \'" + ep_in_payLoad + "\': " + CurrentErrorMessage code 'Schedule-at-procedure' ;
				endif;
			}
			Comment: "Schedule a job in a couple of seconds.";
			Parameter p_in_noSecs {
				Unit: s;
				Property: Input;
			}
			ElementParameter ep_in_payLoad {
				Range: AllProcedures;
				Property: Input;
			}
			StringParameter sp_loc_refDate;
			StringParameter sp_loc_launchDate;
			Parameter p_loc_tmpSec {
				Range: integer;
				Unit: s;
			}
			Parameter p_loc_ogv;
			Parameter p_loc_low;
			Parameter p_loc_scheduleAtUsesUTC;
			Parameter p_loc_def;
			Parameter p_loc_lupp;
		}
	}
	Procedure MainInitialization {
		Body: {
			empty p_init_tourConnect,p_sim_tourConnect,p_cyc_tourConnect;
			
			p_init_tourInitialized := 0;
			p_sim_initialized  := 0;
			p_cyc_initialized  := 0;
			
			block !status bar change
			    sp_statusBar('1', 'icon') := "aimms-circle2";
			    sp_statusBar('1', 'color') := "var(--secondary)";
			    sp_statusBar('1', 'text') := "Ready";
			    sp_statusBar('1', 'tooltip') := "The run is completed.";
			    sp_statusBar('1', 'state') := "active";
			endblock;
		}
	}
	Procedure PostMainInitialization {
		Body: {
			pr_readWorldCities;
		}
	}
	Procedure MainExecution;
	Procedure PreMainTermination {
		Body: {
			return 1;
		}
	}
	Procedure MainTermination {
		Body: {
			return 1 ;
		}
		Comment: "We return 1 to make sure AIMMS does not ask to save a case when closing the project";
	}
}
