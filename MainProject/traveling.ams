## ams_version=1.0

Model Main_TravelingSalesman {
	Comment: {
		"This model illustrates some of AIMMS control flow statements by means of the
		traveling salesman 2-opt heuristic. You will find some declarations to define
		the problem, along with
		- a procedure and some declarations to compute and visualize an initial tour
		  constructed by starting at some city and successively selecting the next
		  city as the closest city not yet part of the tour
		- a procedure and some declarations to compute and visualize an improved tour
		  constructed by repetitively swapping those two arcs in the tour by means of
		  the 2-opt heuristic that give the largest overall distance improvement, until
		  no further improvement is possible or the iteration limit is reached
		- a procedure and some declarations to compute and visualize an improved tour
		  constructed by repetitively swapping the next arc in the (modified) tour
		  with that neighbor arc which gives the largest distance improvement, until
		  the iteration limit is reached or a full cycle over the tour gives no
		  further improvement.
		  
		  Keywords:
		  Algorithm, network object, traveling salesman problem, GMP, Progress Window."
	}
	Section Data_Model {
		Section Quantities_and_Units {
			Comment: {
				"This section contains all the units and quantities that are added automatically by AIMMS.
				It is recommended to declare all your quantities here."
			}
			Quantity SI_Time_Duration {
				BaseUnit: s;
				Conversions: minute->s : #-># * 60;
				Comment: {
					"Expresses the value for the duration of periods.
					
					The unit s has been added automatically because it is a required unit for AimmsWebUI.
					
					The unit minute has been added automatically because it is a required unit for AimmsWebUI."
				}
			}
		}
		Section Inputs {
			Set s_cities {
				Text: "The set of cities in the tour";
				Index: i_i, i_j, i_city;
				Parameter: ep_city;
				Definition: ElementRange( from: 1, to: p_maxCities, fill: 0 );
			}
			Set s_neighbors {
				IndexDomain: i_i;
				SubsetOf: s_cities;
				Text: "The set of neighbors of city i";
				OrderBy: user;
				Definition: NBest(i_j | (i_i <> i_j), -p_def_directDistance(i_i,i_j), p_def_maxNeighbors);
			}
			Parameter p_maxCities {
				Text: "Maximum number of cities in the tour";
				Default: 100;
				InitialData: 100;
			}
			Parameter p_xCoord {
				IndexDomain: i_city;
				Text: "X-Coordinate of city c";
				InitialData: 0;
			}
			Parameter p_yCoord {
				IndexDomain: i_city;
				Text: "Y-Coordinate of city c";
				InitialData: 0;
			}
			Parameter p_def_directDistance {
				IndexDomain: (i_i,i_j);
				Text: "Distance from city i to city j";
				Definition: sqrt( (p_xCoord(i_j) - p_xCoord(i_i))^2 + (p_yCoord(i_j) - p_yCoord(i_i))^2 );
			}
			Parameter p_def_iterationLimit {
				Text: "Maximum number of iterations to improve tour";
				Definition: {
					floor(p_maxCities / 3);
				}
			}
			Parameter p_def_maxNeighbors {
				Text: "Maximum number of neighbors considered for each city";
				Definition: {
					floor(Sqrt(p_maxCities));
				}
			}
		}
		Section Finding_Tours {
			Procedure Initialize_Progress_Window {
				Body: {
					GMP::ProgressWindow::DisplayLine( 2, "Node Swaps", "" );
					GMP::ProgressWindow::DisplayLine( 3, "Objective", "" );
					GMP::ProgressWindow::DisplayProgramStatus( '' );
					GMP::ProgressWindow::DisplaySolverStatus( '' );
				}
			}
			Section Initial_Tour {
				Comment: {
					"This section contains all declarations and procedures necessary to
					compute and visualize the initial tour."
				}
				Parameter p_init_tourDistance {
					Text: "Total distance of the initial tour";
				}
				Parameter p_init_tourConnect {
					IndexDomain: (i_i,i_j);
					Text: "City i connected to city j in initial tour";
				}
				ElementParameter ep_init_nextCity {
					IndexDomain: i_city;
					Text: "Next city of city c in initial tour";
					Range: s_cities;
				}
				ElementParameter ep_init_prevCity {
					IndexDomain: i_city;
					Text: "Previous city of city c in initial tour";
					Range: s_cities;
				}
				Parameter p_init_tourInitialized {
					Text: "Flag to indicate that an initial tour has been computed for a newly created tour";
				}
				Procedure pr_findInitialTour {
					Body: {
						Initialize_Progress_Window;
						GMP::ProgressWindow::DisplayLine( 1, "Phase", "Find Initial Tour" );
						
						empty p_init_tourConnect;
						s_loc_remainingCities := s_cities;
						
						! We start adding the first city to the tour
						ep_city := First(s_cities);
						s_loc_remainingCities -= ep_city;
						
						! For every other city, the next city in the tour is the one closest to it not yet chosen
						while (Card(s_loc_remainingCities) <> 0) do
						    ep_init_nextCity(ep_city) 
						    :=  argmin(i_city in s_loc_remainingCities, p_def_directDistance(ep_city,i_city));
						
						    ep_city := ep_init_nextCity(ep_city);
						    s_loc_remainingCities -= ep_city;
						endwhile;
						
						! Finally, close the tour
						ep_init_nextCity(ep_city) := First(s_cities);
						
						ep_init_prevCity(ep_init_nextCity(i_city)) := i_city;
						p_init_tourConnect(i_city,ep_init_nextCity(i_city)) := 1;
						p_init_tourDistance := sum(i_city, p_def_directDistance(i_city,ep_init_nextCity(i_city)));
						
						p_init_tourInitialized := 1;
					}
					Comment: {
						"This procedure computes an initial tour by starting at the first city,
						and successively adding the closest remaining city."
					}
					Set s_loc_remainingCities {
						SubsetOf: s_cities;
					}
				}
			}
			Section Improve_Tour_Simultaneous {
				Comment: {
					"This section contains all identifiers and the procedure necessary to compute
					and visualize improved tours using an algorithm that selects the neighbor of a
					city for swapping, considering all cities in the tour simultaneously."
				}
				Parameter p_sim_distanceChange {
					IndexDomain: (i_i,i_j in s_neighbors(i_i));
					Text: "Improvement in total tour distance by swapping city i with neighbor j in simultaneous algorithm";
					Default: -inf;
					Definition: p_def_directDistance(i_i,p_sim_nextCity(i_i)) + p_def_directDistance(i_j,p_sim_nextCity(i_j)) - (p_def_directDistance(i_i,i_j) + p_def_directDistance(p_sim_nextCity(i_i),p_sim_nextCity(i_j)));
				}
				Parameter p_sim_maxChange {
					Text: "Maximum possible distance improvement in simultaneous algorithm";
					Definition: Max((i_i,i_j in s_neighbors(i_i)), p_sim_distanceChange(i_i,i_j));
				}
				Parameter p_sim_swaps {
					Text: "Number of performed swaps in simultaneous algorithm";
				}
				Parameter p_sim_tourDistance {
					Text: "Total tour distance after current iteration in simultaneous algorithm";
				}
				Parameter p_sim_tourConnect {
					IndexDomain: (i_i,i_j);
					Text: "City i connected to city j after current iteration in simultaneous algorithm";
				}
				ElementParameter p_sim_nextCity {
					IndexDomain: i_city;
					Text: "Next city of city c after current iteration in simultaneous algorithm";
					Range: s_cities;
				}
				ElementParameter p_sim_prevCity {
					IndexDomain: i_city;
					Text: "Previous city of city c after current iteration in simultaneous algorithm";
					Range: s_cities;
				}
				Parameter p_sim_initialized {
					Text: "Flag to indicate that simultaneous algorithm has been initialized";
				}
				Procedure pr_improveTourSimultaneous {
					Body: {
						Initialize_Progress_Window;
						GMP::ProgressWindow::DisplaySolver("Simultaneous Approach");
						GMP::ProgressWindow::DisplayLine(1, "Phase", "");
						
						if not p_init_tourInitialized then 
						    pr_findInitialTour; 
						endif;
						
						if (not p_sim_initialized) then
						   p_sim_nextCity(i_city) := ep_init_nextCity(i_city);
						   p_sim_prevCity(i_city) := ep_init_prevCity(i_city);
						   p_sim_initialized := 1;
						   p_sim_swaps := 0;
						endif;
						
						while (p_sim_maxChange > 0 and LoopCount <= p_def_iterationLimit) do
						    GMP::ProgressWindow::DisplayLine( 1, "Phase", "Select cities" );
						
						    p_sim_swaps += 1;
						
						    ! Select City and NewNext as a (i,j) tuple which reaches the maximum change
						    for ((i_i,i_j) | p_sim_distanceChange(i_i,i_j) = p_sim_maxChange) do
						        ep_city := i_i;
						        ep_loc_nextCity := i_j;
						        break;
						    endfor;
						
						    block ! Swap cities in tour.
						        ! This is the hairy part of the algorithm. The direction of the tour changes from
						        ! City to NewNext as part of the 2-opt heuristic. To modify the next and previous
						        ! city references we have to walk over the subtour, carefully making sure we don't
						        ! destroy any information while reversing the direction.
						
						        GMP::ProgressWindow::DisplayLine(1, "Phase", "Swap Cities");
						
						        ! Set up a link from the old destinations of City to the old destination of NewNext in the tour
						        ep_loc_OCity := p_sim_nextCity(ep_city);
						        ep_loc_DCity := p_sim_nextCity(ep_loc_nextCity);
						        p_sim_nextCity(ep_loc_OCity) := ep_loc_DCity;
						        p_sim_prevCity(ep_loc_DCity) := ep_loc_OCity;
						
						        ! Reverse the chain from the old destination of City to NextNew
						        ep_loc_OCity := ep_loc_nextCity;
						        ep_loc_DCity := p_sim_prevCity(ep_loc_OCity);
						
						        while ( ep_loc_DCity <> ep_city ) do
						            ep_loc_ODCity := ep_loc_DCity;
						            p_sim_nextCity(ep_loc_OCity) := ep_loc_ODCity;
						            ep_loc_DCity := p_sim_prevCity(ep_loc_ODCity);
						            p_sim_prevCity(ep_loc_ODCity) := ep_loc_OCity;
						            ep_loc_OCity := ep_loc_ODCity;
						        endwhile;
						
						        ! Finally, setup the link from City to NextNew
						        p_sim_nextCity(ep_city) := ep_loc_nextCity;
						        p_sim_prevCity(ep_loc_nextCity) := ep_city;
						    endblock; 
						
						    block ! Update network flow object.
						        empty p_sim_tourConnect;
						        p_sim_tourConnect(i_city, p_sim_nextCity(i_city)) := 1;
						        p_sim_tourDistance := sum(i_city, p_def_directDistance(i_city, p_sim_nextCity(i_city)));
						    endblock; 
						
						    block ! Update Progress Window.
						        GMP::ProgressWindow::DisplayLine(3, "Objective", p_sim_tourDistance);
						        GMP::ProgressWindow::DisplayLine(2, "Node Swaps", p_sim_swaps);
						    endblock; 
						endwhile;
						
						block ! Update Progress Window.
						    GMP::ProgressWindow::DisplayLine(3, "Objective", p_sim_tourDistance);
						    GMP::ProgressWindow::DisplayLine(2, "Node Swaps", p_sim_swaps);
						endblock; 
						
						GMP::ProgressWindow::DisplayProgramStatus('LocallyOptimal');
						GMP::ProgressWindow::DisplaySolverStatus('NormalCompletion');
					}
					ElementParameter ep_loc_nextCity {
						Range: s_cities;
					}
					ElementParameter ep_loc_OCity {
						Range: s_cities;
					}
					ElementParameter ep_loc_DCity {
						Range: s_cities;
					}
					ElementParameter ep_loc_ODCity {
						Range: s_cities;
					}
				}
			}
			Section Improve_Tour_Cyclic {
				Comment: {
					"This section contains all identifiers and the procedure necessary to compute
					and visualize improved tours using an algorithm that selects that neighbor of the
					next city in the (modified) tour for swapping which causes the largest distance
					improvement."
				}
				Macro p_cyc_distanceChange {
					Text: "Improvement in total tour distance by swapping city i with neighbor j in cyclic algorithm";
					Arguments: (i_i,i_j);
					Definition: p_def_directDistance(i_i,p_cyc_nextCity(i_i)) + p_def_directDistance(i_j,p_cyc_nextCity(i_j)) - (p_def_directDistance(i_i,i_j) + p_def_directDistance(p_cyc_nextCity(i_i),p_cyc_nextCity(i_j)));
				}
				Parameter p_cyc_swaps {
					Text: "Number of performed swaps in cyclic algorithm";
				}
				Parameter p_cyc_tourDistance {
					Text: "Total tour distance after current iteration in cyclic algorithm";
				}
				Parameter p_cyc_tourConnect {
					IndexDomain: (i_i,i_j);
					Text: "City i connected to city j after current iteration in cyclic algorithm";
				}
				ElementParameter p_cyc_nextCity {
					IndexDomain: i_city;
					Text: "Next city of city c after current iteration in cyclic algorithm";
					Range: s_cities;
				}
				ElementParameter p_cyc_prevCity {
					IndexDomain: i_city;
					Text: "Previous city of city c after current iteration in cyclic algorithm";
					Range: s_cities;
				}
				Parameter p_cyc_initialized {
					Text: "Flag to indicate that cyclic algorithm has been initialized";
				}
				Procedure pr_improveTourCyclic {
					Body: {
						Initialize_Progress_Window;
						GMP::ProgressWindow::DisplaySolver("Cyclic Approach");
						GMP::ProgressWindow::DisplayLine(1, "Phase", "");
						
						if not p_init_tourInitialized then 
						    pr_findInitialTour; 
						endif;
						
						if (not p_cyc_initialized) then
						   p_cyc_nextCity(i_city) := ep_init_nextCity(i_city);
						   p_cyc_prevCity(i_city) := ep_init_prevCity(i_city);
						   p_cyc_initialized := 1;
						   p_cyc_swaps := 0;
						endif;
						
						p_loc_uselessLoops := 0;
						ep_city := First(s_cities);
						
						while (p_cyc_swaps < p_def_iterationLimit 
						        and p_loc_uselessLoops <= p_maxCities) do
						
						    GMP::ProgressWindow::DisplayLine(1, "Phase", "Select cities");
						
						    p_loc_uselessLoops += 1;
						
						    ! Select a NewNext to be swapped with City
						    ep_loc_nextCity := argmax(i_city in s_neighbors(ep_city), p_cyc_distanceChange(ep_city,i_city));
						
						    if (p_cyc_distanceChange(ep_city, ep_loc_nextCity) > 0) then
						        p_cyc_swaps += 1;
						        p_loc_uselessLoops := 0;
						
						        block ! Swap cities in tour.
						            ! This is the hairy part of the algorithm. The direction of the tour changes from
						            ! City to NewNext as part of the 2-opt heuristic. To modify the next and previous
						            ! city references we have to walk over the subtour, carefully making sure we don't
						            ! destroy any information while reversing the direction.
						
						            GMP::ProgressWindow::DisplayLine( 1, "Phase", "Swap Cities" );
						
						            ! Set up a link from the old destinations of City to the old destination of NewNext in the tour
						            ep_loc_OCity := p_cyc_NextCity(ep_city);
						            ep_loc_DCity := p_cyc_nextCity(ep_loc_nextCity);
						            p_cyc_nextCity(ep_loc_OCity) := ep_loc_DCity;
						            p_cyc_prevCity(ep_loc_DCity) := ep_loc_OCity;
						
						            ! Reverse the chain from the old destination of City to NextNew
						            ep_loc_OCity := ep_loc_nextCity;
						            ep_loc_DCity := p_cyc_prevCity(ep_loc_OCity);
						
						            while ( ep_loc_DCity <> ep_city ) do
						                 ep_loc_ODCity := ep_loc_DCity;
						                 p_cyc_NextCity(ep_loc_OCity) := ep_loc_ODCity;
						                 ep_loc_DCity := p_cyc_prevCity(ep_loc_ODCity);
						                 p_cyc_prevCity(ep_loc_ODCity) := ep_loc_OCity;
						                 ep_loc_OCity := ep_loc_ODCity;
						            endwhile;
						
						            ! Finally, setup the link from City to NextNew
						            p_cyc_NextCity(ep_city) := ep_loc_nextCity;
						            p_cyc_PrevCity(ep_loc_nextCity) := ep_city;
						        endblock;
						
						        block ! Update network flow object.
						            empty p_cyc_TourConnect;
						            p_cyc_TourConnect(i_city,p_cyc_NextCity(i_city)) := 1;
						            p_cyc_TourDistance := sum(i_city, p_def_directDistance(i_city,p_cyc_nextCity(i_city)));
						            PageRefreshAll;
						        endblock;
						
						        block ! Update Progress Window.
						            GMP::ProgressWindow::DisplayLine(3,"Objective", p_cyc_TourDistance);
						            GMP::ProgressWindow::DisplayLine(2, "Node Swaps", p_cyc_Swaps);
						        endblock;
						    endif;
						
						    ep_city := p_cyc_nextCity(ep_city);
						endwhile;
						
						GMP::ProgressWindow::DisplayProgramStatus('LocallyOptimal');
						GMP::ProgressWindow::DisplaySolverStatus('NormalCompletion');
						
						block ! Update Progress Window.
						    GMP::ProgressWindow::DisplayLine(3,"Objective", p_cyc_tourDistance);
						    GMP::ProgressWindow::DisplayLine(2, "Node Swaps", p_cyc_swaps);
						endblock;
					}
					Parameter p_loc_uselessLoops {
						Text: "Counter for counting number of iterations without tour improvement";
					}
					ElementParameter ep_loc_nextCity {
						Range: s_cities;
					}
					ElementParameter ep_loc_OCity {
						Range: s_cities;
					}
					ElementParameter ep_loc_DCity {
						Range: s_cities;
					}
					ElementParameter ep_loc_ODCity {
						Range: s_cities;
					}
				}
			}
		}
	}
	Section UI_Declarations {
		Procedure pr_empty;
		StringParameter sp_logo {
			InitialData: "aimms_logo.png";
		}
		Section Workflow {
			StringParameter sp_myWorkflows {
				IndexDomain: (webui::indexWorkflowOrder,webui::indexWorkflowSpec);
			}
			StringParameter sp_myWorkflowSteps {
				IndexDomain: (webui::indexWorkflowOrder,webui::indexNoOfPages,webui::indexWorkflowPageSpec);
				Definition: {
					data 
					{ ( 1, 1, displayText       ) : "Welcome"            ,  ( 1, 1, icon              ) : "aimms-happy"        ,
					  ( 1, 1, pageId            ) : "home"               ,  ( 1, 1, tooltip           ) : "welcome"            ,
					  ( 1, 1, workflowPageState ) : "active"             ,  ( 1, 1, pageDataState     ) : "Incomplete"         ,
					  ( 1, 1, redirectPageId    ) : "home"               ,  ( 1, 2, displayText       ) : "Story"              ,
					  ( 1, 2, icon              ) : "aimms-lamp5"        ,  ( 1, 2, pageId            ) : "story"              ,
					  ( 1, 2, tooltip           ) : "Problem description",  ( 1, 2, workflowPageState ) : "active"             ,
					  ( 1, 2, pageDataState     ) : "Incomplete"         ,  ( 1, 2, redirectPageId    ) : "home"               ,
					  ( 1, 3, displayText       ) : "Tours"              ,  ( 1, 3, icon              ) : "aimms-finish"       ,
					  ( 1, 3, pageId            ) : "tours"              ,  ( 1, 3, tooltip           ) : "Possible Tours"     ,
					  ( 1, 3, workflowPageState ) : "active"             ,  ( 1, 3, pageDataState     ) : "Incomplete"         ,
					  ( 1, 3, redirectPageId    ) : "home"                }
				}
			}
		}
		Section Pages {
			Section Tours_Page {
				Procedure pr_runAll {
					Body: {
						pr_improveTourCyclic;
						pr_improveTourSimultaneous;
						pr_findInitialTour;
					}
				}
				StringParameter sp_toursSidePanel {
					IndexDomain: (webui::indexPageExtension,webui::indexSidePanelSpec);
					Definition: {
						data 
						{ ( 1, displayText ) : "New Network"   ,  ( 1, pageId      ) : "new_network"   ,  ( 1, state       ) : "active"        ,
						  ( 2, displayText ) : "Tour Distances",  ( 2, pageId      ) : "tour_distances",  ( 2, state       ) : "active"         }
					}
				}
			}
		}
		Section FlagsIdentifier {
			StringParameter sp_readOnlyFlag {
				Definition: "readonly";
			}
		}
	}
	Procedure MainInitialization {
		Body: {
			empty p_init_tourConnect,p_sim_tourConnect,p_cyc_tourConnect;
			
			p_init_tourInitialized := 0;
			p_sim_initialized  := 0;
			p_cyc_initialized  := 0;
		}
	}
	Procedure PostMainInitialization;
	Procedure MainExecution;
	Procedure PreMainTermination {
		Body: {
			return 1;
		}
	}
	Procedure MainTermination {
		Body: {
			return 1;
		}
		Comment: "We return 1 to make sure AIMMS does not ask to save a case when closing the project";
	}
}
