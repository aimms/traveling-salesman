## ams_version=1.0

Model Main_TravelingSalesman {
	Comment: {
		"This model illustrates some of AIMMS control flow statements by means of the
		traveling salesman 2-opt heuristic. You will find some declarations to define
		the problem, along with
		- a procedure and some declarations to compute and visualize an initial tour
		  constructed by starting at some city and successively selecting the next
		  city as the closest city not yet part of the tour
		- a procedure and some declarations to compute and visualize an improved tour
		  constructed by repetitively swapping those two arcs in the tour by means of
		  the 2-opt heuristic that give the largest overall distance improvement, until
		  no further improvement is possible or the iteration limit is reached
		- a procedure and some declarations to compute and visualize an improved tour
		  constructed by repetitively swapping the next arc in the (modified) tour
		  with that neighbor arc which gives the largest distance improvement, until
		  the iteration limit is reached or a full cycle over the tour gives no
		  further improvement.
		  
		  Keywords:
		  Algorithm, network object, traveling salesman problem, GMP, Progress Window."
	}
	Section Data_Model {
		Section Quantities_and_Units {
			Comment: {
				"This section contains all the units and quantities that are added automatically by AIMMS.
				It is recommended to declare all your quantities here."
			}
			Quantity SI_Time_Duration {
				BaseUnit: s;
				Conversions: minute->s : #-># * 60;
				Comment: {
					"Expresses the value for the duration of periods.
					
					The unit s has been added automatically because it is a required unit for AimmsWebUI.
					
					The unit minute has been added automatically because it is a required unit for AimmsWebUI."
				}
			}
		}
		Section Inputs {
			DeclarationSection DB_Inputs {
				Set s_ids {
					Index: i_id;
					Parameter: ep_id;
				}
				Set s_cities {
					Text: "The set of cities in the tour";
					Index: i_city1, i_city2, i_city;
					Parameter: ep_city;
				}
				Set s_citiesASCII {
					Index: i_city_ascii;
					Parameter: ep_cityASCII;
				}
				Set s_countries {
					Index: i_country;
					Parameter: ep_country;
				}
				Set s_provinces {
					Index: i_province;
					Parameter: ep_province;
				}
				StringParameter sp_countryAcronym {
					IndexDomain: i_country;
				}
				Parameter bp_city_x_country {
					IndexDomain: (i_city,i_country);
				}
				Parameter bp_city_x_id {
					IndexDomain: (i_city,i_id);
				}
				Parameter bp_city_x_cityASCII {
					IndexDomain: (i_city,i_city_ascii);
				}
				Parameter bp_city_x_province {
					IndexDomain: (i_city,i_province);
				}
			}
			DeclarationSection API_Inputs {
				Set s_nodes {
					SubsetOf: s_cities;
					Index: i_node1, i_node2;
					Parameter: ep_node;
					Definition: {
						{i_city | 
						        p_latitude(i_city)
						        and p_longitude(i_city)}
					}
				}
				Parameter p_def_cardinalityOfNodes {
					Definition: card(s_nodes);
				}
				Set s_neighbors {
					IndexDomain: i_node1;
					SubsetOf: s_cities;
					Text: "The set of neighbors of city i";
					OrderBy: user;
					Definition: NBest(i_node2 | (i_node1 <> i_node2), -p_def_directDistance(i_node1,i_node2), p_def_maxNeighbors);
				}
				Parameter p_maxCities {
					Text: "Maximum number of cities in the tour";
					Default: 100;
					InitialData: 100;
				}
				Parameter p_latitude {
					IndexDomain: i_city;
					Text: "X-Coordinate of city c";
					InitialData: 0;
				}
				Parameter p_longitude {
					IndexDomain: i_city;
					Text: "Y-Coordinate of city c";
					InitialData: 0;
				}
				Parameter p_def_directDistance {
					IndexDomain: (i_node1,i_node2);
					Text: "Distance from city i to city j";
					Definition: sqrt( (p_latitude(i_node2) - p_latitude(i_node1))^2 + (p_longitude(i_node2) - p_longitude(i_node1))^2 );
				}
				Parameter p_def_iterationLimit {
					Text: "Maximum number of iterations to improve tour";
					Definition: {
						floor(p_maxCities / 3);
					}
				}
				Parameter p_def_maxNeighbors {
					Text: "Maximum number of neighbors considered for each city";
					Definition: {
						floor(Sqrt(p_maxCities));
					}
				}
			}
		}
		Section Finding_Tours {
			Procedure Initialize_Progress_Window {
				Body: {
					GMP::ProgressWindow::DisplayLine( 2, "Node Swaps", "" );
					GMP::ProgressWindow::DisplayLine( 3, "Objective", "" );
					GMP::ProgressWindow::DisplayProgramStatus( '' );
					GMP::ProgressWindow::DisplaySolverStatus( '' );
				}
			}
			Section Initial_Tour {
				Comment: {
					"This section contains all declarations and procedures necessary to
					compute and visualize the initial tour."
				}
				Parameter p_init_tourDistance {
					Text: "Total distance of the initial tour";
				}
				Parameter p_init_tourConnect {
					IndexDomain: (i_node1,i_node2);
					Text: "City i connected to city j in initial tour";
				}
				ElementParameter ep_init_nextCity {
					IndexDomain: i_city;
					Text: "Next city of city c in initial tour";
					Range: s_cities;
				}
				ElementParameter ep_init_prevCity {
					IndexDomain: i_city;
					Text: "Previous city of city c in initial tour";
					Range: s_cities;
				}
				Parameter p_init_tourInitialized {
					Text: "Flag to indicate that an initial tour has been computed for a newly created tour";
				}
				Procedure pr_findInitialTour {
					Body: {
						empty Initial_Tour;
						
						Initialize_Progress_Window;
						GMP::ProgressWindow::DisplayLine( 1, "Phase", "Find Initial Tour" );
						
						empty p_init_tourConnect;
						s_loc_remainingCities := s_nodes;
						
						! We start adding the first city to the tour
						ep_node := First(s_nodes);
						s_loc_remainingCities -= ep_node;
						
						! For every other city, the next city in the tour is the one closest to it not yet chosen
						while (Card(s_loc_remainingCities) <> 0) do
						    ep_init_nextCity(ep_node) 
						    :=  argmin(i_node1 in s_loc_remainingCities, p_def_directDistance(ep_node,i_node1));
						
						    ep_node := ep_init_nextCity(ep_node);
						    s_loc_remainingCities -= ep_node;
						endwhile;
						
						! Finally, close the tour
						ep_init_nextCity(ep_node) := First(s_nodes);
						
						ep_init_prevCity(ep_init_nextCity(i_node1)) := i_node1;
						p_init_tourConnect(i_node1,ep_init_nextCity(i_node1)) := 1;
						p_init_tourDistance := sum(i_node1, p_def_directDistance(i_node1,ep_init_nextCity(i_node1)));
						
						p_init_tourInitialized := 1;
					}
					Comment: {
						"This procedure computes an initial tour by starting at the first city,
						and successively adding the closest remaining city."
					}
					Set s_loc_remainingCities {
						SubsetOf: s_cities;
					}
				}
			}
			Section Improve_Tour_Simultaneous {
				Comment: {
					"This section contains all identifiers and the procedure necessary to compute
					and visualize improved tours using an algorithm that selects the neighbor of a
					city for swapping, considering all cities in the tour simultaneously."
				}
				Parameter p_sim_distanceChange {
					IndexDomain: (i_node1,i_node2);
					Text: "Improvement in total tour distance by swapping city i with neighbor j in simultaneous algorithm";
					Default: -inf;
					Definition: p_def_directDistance(i_node1,p_sim_nextCity(i_node1)) + p_def_directDistance(i_node2,p_sim_nextCity(i_node2)) - (p_def_directDistance(i_node1,i_node2) + p_def_directDistance(p_sim_nextCity(i_node1),p_sim_nextCity(i_node2)));
				}
				Parameter p_sim_maxChange {
					Text: "Maximum possible distance improvement in simultaneous algorithm";
					Definition: Max((i_node1,i_node2 in s_neighbors(i_node1)), p_sim_distanceChange(i_node1,i_node2));
				}
				Parameter p_sim_swaps {
					Text: "Number of performed swaps in simultaneous algorithm";
				}
				Parameter p_sim_tourDistance {
					Text: "Total tour distance after current iteration in simultaneous algorithm";
					InitialData: 0;
				}
				Parameter p_sim_tourConnect {
					IndexDomain: (i_node1,i_node2);
					Text: "City i connected to city j after current iteration in simultaneous algorithm";
				}
				ElementParameter p_sim_nextCity {
					IndexDomain: i_city;
					Text: "Next city of city c after current iteration in simultaneous algorithm";
					Range: s_cities;
				}
				ElementParameter p_sim_prevCity {
					IndexDomain: i_city;
					Text: "Previous city of city c after current iteration in simultaneous algorithm";
					Range: s_cities;
				}
				Parameter p_sim_initialized {
					Text: "Flag to indicate that simultaneous algorithm has been initialized";
				}
				Procedure pr_improveTourSimultaneous {
					Body: {
						empty Improve_Tour_Simultaneous;
						
						Initialize_Progress_Window;
						GMP::ProgressWindow::DisplaySolver("Simultaneous Approach");
						GMP::ProgressWindow::DisplayLine(1, "Phase", "");
						
						if not p_init_tourInitialized then 
						    pr_findInitialTour; 
						endif;
						
						if (not p_sim_initialized) then
						   p_sim_nextCity(i_node1) := ep_init_nextCity(i_node1);
						   p_sim_prevCity(i_node1) := ep_init_prevCity(i_node1);
						   p_sim_initialized := 1;
						   p_sim_swaps := 0;
						endif;
						
						while (p_sim_maxChange > 0 and LoopCount <= p_def_iterationLimit) do
						    GMP::ProgressWindow::DisplayLine( 1, "Phase", "Select cities" );
						
						    p_sim_swaps += 1;
						
						    ! Select City and NewNext as a (i,j) tuple which reaches the maximum change
						    for ((i_node1,i_node2) | p_sim_distanceChange(i_node1,i_node2) = p_sim_maxChange) do
						        ep_node := i_node1;
						        ep_loc_nextCity := i_node2;
						        break;
						    endfor;
						
						    block ! Swap cities in tour.
						        ! This is the hairy part of the algorithm. The direction of the tour changes from
						        ! City to NewNext as part of the 2-opt heuristic. To modify the next and previous
						        ! city references we have to walk over the subtour, carefully making sure we don't
						        ! destroy any information while reversing the direction.
						
						        GMP::ProgressWindow::DisplayLine(1, "Phase", "Swap Cities");
						
						        ! Set up a link from the old destinations of City to the old destination of NewNext in the tour
						        ep_loc_OCity := p_sim_nextCity(ep_node);
						        ep_loc_DCity := p_sim_nextCity(ep_loc_nextCity);
						        p_sim_nextCity(ep_loc_OCity) := ep_loc_DCity;
						        p_sim_prevCity(ep_loc_DCity) := ep_loc_OCity;
						
						        ! Reverse the chain from the old destination of City to NextNew
						        ep_loc_OCity := ep_loc_nextCity;
						        ep_loc_DCity := p_sim_prevCity(ep_loc_OCity);
						
						        while ( ep_loc_DCity <> ep_node ) do
						            ep_loc_ODCity := ep_loc_DCity;
						            p_sim_nextCity(ep_loc_OCity) := ep_loc_ODCity;
						            ep_loc_DCity := p_sim_prevCity(ep_loc_ODCity);
						            p_sim_prevCity(ep_loc_ODCity) := ep_loc_OCity;
						            ep_loc_OCity := ep_loc_ODCity;
						        endwhile;
						
						        ! Finally, setup the link from City to NextNew
						        p_sim_nextCity(ep_node) := ep_loc_nextCity;
						        p_sim_prevCity(ep_loc_nextCity) := ep_node;
						    endblock; 
						
						    block ! Update network flow object.
						        empty p_sim_tourConnect;
						        p_sim_tourConnect(i_node1, p_sim_nextCity(i_node1)) := 1;
						        p_sim_tourDistance := sum(i_node1, p_def_directDistance(i_node1, p_sim_nextCity(i_node1)));
						    endblock; 
						
						    block ! Update Progress Window.
						        GMP::ProgressWindow::DisplayLine(3, "Objective", p_sim_tourDistance);
						        GMP::ProgressWindow::DisplayLine(2, "Node Swaps", p_sim_swaps);
						    endblock; 
						endwhile;
						
						block ! Update Progress Window.
						    GMP::ProgressWindow::DisplayLine(3, "Objective", p_sim_tourDistance);
						    GMP::ProgressWindow::DisplayLine(2, "Node Swaps", p_sim_swaps);
						endblock; 
						
						GMP::ProgressWindow::DisplayProgramStatus('LocallyOptimal');
						GMP::ProgressWindow::DisplaySolverStatus('NormalCompletion');
					}
					ElementParameter ep_loc_nextCity {
						Range: s_cities;
					}
					ElementParameter ep_loc_OCity {
						Range: s_cities;
					}
					ElementParameter ep_loc_DCity {
						Range: s_cities;
					}
					ElementParameter ep_loc_ODCity {
						Range: s_cities;
					}
				}
			}
			Section Improve_Tour_Cyclic {
				Comment: {
					"This section contains all identifiers and the procedure necessary to compute
					and visualize improved tours using an algorithm that selects that neighbor of the
					next city in the (modified) tour for swapping which causes the largest distance
					improvement."
				}
				Macro p_cyc_distanceChange {
					Text: "Improvement in total tour distance by swapping city i with neighbor j in cyclic algorithm";
					Arguments: (i_node1,i_node2);
					Definition: p_def_directDistance(i_node1,p_cyc_nextCity(i_node1)) + p_def_directDistance(i_node2,p_cyc_nextCity(i_node2)) - (p_def_directDistance(i_node1,i_node2) + p_def_directDistance(p_cyc_nextCity(i_node1),p_cyc_nextCity(i_node2)));
				}
				Parameter p_cyc_swaps {
					Text: "Number of performed swaps in cyclic algorithm";
				}
				Parameter p_cyc_tourDistance {
					Text: "Total tour distance after current iteration in cyclic algorithm";
					InitialData: 0;
				}
				Parameter p_cyc_tourConnect {
					IndexDomain: (i_node1,i_node2);
					Text: "City i connected to city j after current iteration in cyclic algorithm";
				}
				ElementParameter p_cyc_nextCity {
					IndexDomain: i_city;
					Text: "Next city of city c after current iteration in cyclic algorithm";
					Range: s_cities;
				}
				ElementParameter p_cyc_prevCity {
					IndexDomain: i_city;
					Text: "Previous city of city c after current iteration in cyclic algorithm";
					Range: s_cities;
				}
				Parameter p_cyc_initialized {
					Text: "Flag to indicate that cyclic algorithm has been initialized";
				}
				Procedure pr_improveTourCyclic {
					Body: {
						empty Improve_Tour_Cyclic;
						
						Initialize_Progress_Window;
						GMP::ProgressWindow::DisplaySolver("Cyclic Approach");
						GMP::ProgressWindow::DisplayLine(1, "Phase", "");
						
						if not p_init_tourInitialized then 
						    pr_findInitialTour; 
						endif;
						
						if (not p_cyc_initialized) then
						   p_cyc_nextCity(i_node1) := ep_init_nextCity(i_node1);
						   p_cyc_prevCity(i_node1) := ep_init_prevCity(i_node1);
						   p_cyc_initialized := 1;
						   p_cyc_swaps := 0;
						endif;
						
						p_loc_uselessLoops := 0;
						ep_node := First(s_nodes);
						
						while (p_cyc_swaps < p_def_iterationLimit 
						        and p_loc_uselessLoops <= p_maxCities) do
						
						    GMP::ProgressWindow::DisplayLine(1, "Phase", "Select cities");
						
						    p_loc_uselessLoops += 1;
						
						    ! Select a NewNext to be swapped with City
						    ep_loc_nextCity := argmax(i_node1 in s_neighbors(ep_node), p_cyc_distanceChange(ep_node,i_node1));
						
						    if (p_cyc_distanceChange(ep_node, ep_loc_nextCity) > 0) then
						        p_cyc_swaps += 1;
						        p_loc_uselessLoops := 0;
						
						        block ! Swap cities in tour.
						            ! This is the hairy part of the algorithm. The direction of the tour changes from
						            ! City to NewNext as part of the 2-opt heuristic. To modify the next and previous
						            ! city references we have to walk over the subtour, carefully making sure we don't
						            ! destroy any information while reversing the direction.
						
						            GMP::ProgressWindow::DisplayLine( 1, "Phase", "Swap Cities" );
						
						            ! Set up a link from the old destinations of City to the old destination of NewNext in the tour
						            ep_loc_OCity := p_cyc_NextCity(ep_node);
						            ep_loc_DCity := p_cyc_nextCity(ep_loc_nextCity);
						            p_cyc_nextCity(ep_loc_OCity) := ep_loc_DCity;
						            p_cyc_prevCity(ep_loc_DCity) := ep_loc_OCity;
						
						            ! Reverse the chain from the old destination of City to NextNew
						            ep_loc_OCity := ep_loc_nextCity;
						            ep_loc_DCity := p_cyc_prevCity(ep_loc_OCity);
						
						            while ( ep_loc_DCity <> ep_node ) do
						                 ep_loc_ODCity := ep_loc_DCity;
						                 p_cyc_NextCity(ep_loc_OCity) := ep_loc_ODCity;
						                 ep_loc_DCity := p_cyc_prevCity(ep_loc_ODCity);
						                 p_cyc_prevCity(ep_loc_ODCity) := ep_loc_OCity;
						                 ep_loc_OCity := ep_loc_ODCity;
						            endwhile;
						
						            ! Finally, setup the link from City to NextNew
						            p_cyc_NextCity(ep_node) := ep_loc_nextCity;
						            p_cyc_PrevCity(ep_loc_nextCity) := ep_node;
						        endblock;
						
						        block ! Update network flow object.
						            empty p_cyc_tourConnect;
						            p_cyc_TourConnect(i_node1,p_cyc_NextCity(i_node1)) := 1;
						            p_cyc_TourDistance := sum(i_node1, p_def_directDistance(i_node1,p_cyc_nextCity(i_node1)));
						
						        endblock;
						
						        block ! Update Progress Window.
						            GMP::ProgressWindow::DisplayLine(3,"Objective", p_cyc_TourDistance);
						            GMP::ProgressWindow::DisplayLine(2, "Node Swaps", p_cyc_Swaps);
						        endblock;
						    endif;
						
						    ep_node := p_cyc_nextCity(ep_node);
						endwhile;
						
						GMP::ProgressWindow::DisplayProgramStatus('LocallyOptimal');
						GMP::ProgressWindow::DisplaySolverStatus('NormalCompletion');
						
						block ! Update Progress Window.
						    GMP::ProgressWindow::DisplayLine(3,"Objective", p_cyc_tourDistance);
						    GMP::ProgressWindow::DisplayLine(2, "Node Swaps", p_cyc_swaps);
						endblock;
					}
					Parameter p_loc_uselessLoops {
						Text: "Counter for counting number of iterations without tour improvement";
					}
					ElementParameter ep_loc_nextCity {
						Range: s_cities;
					}
					ElementParameter ep_loc_OCity {
						Range: s_cities;
					}
					ElementParameter ep_loc_DCity {
						Range: s_cities;
					}
					ElementParameter ep_loc_ODCity {
						Range: s_cities;
					}
				}
			}
		}
	}
	Section UI_Declarations {
		Procedure pr_empty;
		StringParameter sp_logo {
			InitialData: "aimms_logo.png";
		}
		Section Workflow {
			StringParameter sp_myWorkflows {
				IndexDomain: (webui::indexWorkflowOrder,webui::indexWorkflowSpec);
			}
			StringParameter sp_myWorkflowSteps {
				IndexDomain: (webui::indexWorkflowOrder,webui::indexNoOfPages,webui::indexWorkflowPageSpec);
				Definition: {
					data 
					{ ( 1, 1, displayText       ) : "Welcome"            ,  ( 1, 1, icon              ) : "aimms-happy"        ,
					  ( 1, 1, pageId            ) : "home"               ,  ( 1, 1, tooltip           ) : "welcome"            ,
					  ( 1, 1, workflowPageState ) : "active"             ,  ( 1, 1, pageDataState     ) : "Incomplete"         ,
					  ( 1, 1, redirectPageId    ) : "home"               ,  ( 1, 2, displayText       ) : "Story"              ,
					  ( 1, 2, icon              ) : "aimms-lamp5"        ,  ( 1, 2, pageId            ) : "story"              ,
					  ( 1, 2, tooltip           ) : "Problem description",  ( 1, 2, workflowPageState ) : "active"             ,
					  ( 1, 2, pageDataState     ) : "Incomplete"         ,  ( 1, 2, redirectPageId    ) : "home"               ,
					  ( 1, 3, displayText       ) : "Tours"              ,  ( 1, 3, icon              ) : "aimms-finish"       ,
					  ( 1, 3, pageId            ) : "tours"              ,  ( 1, 3, tooltip           ) : "Possible Tours"     ,
					  ( 1, 3, workflowPageState ) : "active"             ,  ( 1, 3, pageDataState     ) : "Incomplete"         ,
					  ( 1, 3, redirectPageId    ) : "home"                }
				}
			}
		}
		Section Pages {
			Section Tours_Page {
				Procedure pr_runAll {
					Body: {
						pr_findInitialTour;
						pr_improveTourCyclic;
						pr_improveTourSimultaneous;
					}
				}
				StringParameter sp_toursSidePanel {
					IndexDomain: (webui::indexPageExtension,webui::indexSidePanelSpec);
					Definition: {
						data 
						{ ( 1, displayText ) : "New Network"   ,  ( 1, pageId      ) : "new_network"   ,  ( 1, state       ) : "active"        ,
						  ( 2, displayText ) : "Tour Distances",  ( 2, pageId      ) : "tour_distances",  ( 2, state       ) : "active"         }
					}
				}
			}
			Section Add_Cities_DialogPage {
				StringParameter sp_addThisCity;
				StringParameter sp_addByCountry;
				Procedure pr_addThisCity {
					Body: {
						ep_city := StringToElement(s_cities, sp_addThisCity, 0);
						
						ep_loc_cityCountry := first(i_country | bp_city_x_country(ep_city, i_country));
						
						if ep_loc_cityCountry then
						    pr_callAPIQuery(sp_addThisCity, ep_loc_cityCountry);
						else
						    raise error "No city with this name";   
						endif;
					}
					ElementParameter ep_loc_cityCountry {
						Range: s_countries;
					}
				}
				Procedure pr_addByCountry {
					Body: {
						empty ep_country, p_latitude, p_longitude;
						
						ep_country := StringToElement(s_countries, sp_addByCountry, 0);
						
						if sp_addByCountry and ep_country then
						    p_loc_cardinalityOfCitiesFromCountry  
						    :=  sum(i_id | exists(i_city | 
						                    bp_city_x_id(i_city, i_id) 
						                    and bp_city_x_country(i_city, ep_country)), 1);
						
						    s_loc_newIds := {1 .. p_loc_cardinalityOfCitiesFromCountry};
						    ep_loc_newId := first(i_loc_newid);
						
						    for i_id | exists(i_city | 
						                    bp_city_x_id(i_city, i_id) 
						                    and bp_city_x_country(i_city, ep_country)) do
						
						        bp_loc_oldId_x_newId(i_id, ep_loc_newId) :=  1;
						        ep_loc_newId += 1;
						    endfor;    
						
						    while p_loc_counter <= p_maxCities do
						        p_loc_randomNewId := ceil(uniform(val(first(i_loc_newid)), val(last(i_loc_newid))));
						        ep_loc_newId := StringToElement(s_loc_newIds, p_loc_randomNewId, 0);
						        ep_city := first(i_city | exists(i_id |  bp_loc_oldId_x_newId(i_id, ep_loc_newId) and bp_city_x_id(i_city, i_id)));
						
						        if ep_country and ep_city then
						            pr_callAPIQuery(ep_city, ep_country);
						        endif;
						
						        p_loc_counter += 1;
						    endwhile; 
						else 
						    raise error "No country with this name";   
						endif;
					}
					Set s_loc_newIds {
						Index: i_loc_newid;
						Parameter: ep_loc_newId;
					}
					ElementParameter ep_loc_cityCountry {
						Range: s_countries;
					}
					Parameter p_loc_randomNewId;
					Parameter p_loc_counter;
					Parameter p_loc_cardinalityOfCitiesFromCountry;
					Parameter bp_loc_oldId_x_newId {
						IndexDomain: (i_id,i_loc_newid);
						Range: binary;
					}
				}
				Procedure pr_addByLimit {
					Body: {
						empty ep_country, ep_city, p_latitude, p_longitude;
						
						while p_loc_counter <= p_maxCities do
						    p_loc_randomId := ceil(uniform(val(first(i_id)), val(last(i_id))));
						    ep_id := StringToElement(s_ids, p_loc_randomId, 0);
						
						    ep_city := first(i_city | bp_city_x_id(i_city, ep_id));
						    ep_country := first(i_country | bp_city_x_country(ep_city, i_country));
						
						    if ep_country and ep_city then
						        pr_callAPIQuery(ep_city, ep_country);
						    endif;
						
						    p_loc_counter += 1;
						endwhile;
					}
					Parameter p_loc_counter;
					Parameter p_loc_randomId;
				}
				Procedure pr_cleanAllNodes {
					Body: {
						empty API_Inputs;
					}
				}
			}
		}
		Section FlagsIdentifier {
			StringParameter sp_readOnlyFlag {
				Definition: "readonly";
			}
		}
	}
	Section Integration {
		Section World_Cities_DB {
			Procedure pr_readWorldCities {
				Body: {
					empty World_Cities_DB;
					read from table db_worldCities;
					
					if exists(i_int_id | sp_int_city(i_int_id)) then
					
					    for i_int_id | sp_int_city(i_int_id) do
					        ep_id := StringToElement(s_ids, val(i_int_id) + 10000, 1); 
					        SetElementAdd(s_cities, ep_city, sp_int_city(i_int_id));
					        SetElementAdd(s_citiesASCII, ep_cityASCII, sp_int_cityASCII(i_int_id));
					        SetElementAdd(s_countries, ep_country, sp_int_country(i_int_id));
					        SetElementAdd(s_provinces, ep_province, sp_int_province(i_int_id));
					
					        sp_countryAcronym(ep_country) := sp_int_countryAcronym(i_int_id);
					
					        bp_city_x_country(ep_city,ep_country) := 1;
					        bp_city_x_cityASCII(ep_city, ep_cityASCII) := 1;
					        bp_city_x_province(ep_city, ep_province) := 1;
					        bp_city_x_id(ep_city, ep_id) := 1;
					    endfor;
					endif;
				}
			}
			StringParameter sp_def_datasource {
				Definition: {
					SQLCreateConnectionString (
					       DatabaseInterface              :  'odbc',
					       DriverName                     :  "SQLite3 ODBC Driver", !Your local drive
					       ServerName                     :  "", 
					       DatabaseName                   :  "WorldCities.db", !The path of your database
					       UserId                         :  "", 
					       Password                       :  "", 
					       AdditionalConnectionParameters :  "");
				}
			}
			DatabaseTable db_worldCities {
				DataSource: sp_def_datasource;
				TableName: "worldCities";
				Mapping: {
					"ID"   -->i_int_id,
					"City" -->sp_int_city,
					"CityASCII" -->sp_int_cityASCII,
					"Country" -->sp_int_country,
					"ISO" -->sp_int_countryAcronym,
					"Province" -->sp_int_province
				}
			}
			Set s_int_id {
				Index: i_int_id;
				Definition: {
					{1..7400}
				}
			}
			StringParameter sp_int_city {
				IndexDomain: i_int_id;
			}
			StringParameter sp_int_cityASCII {
				IndexDomain: i_int_id;
			}
			StringParameter sp_int_country {
				IndexDomain: i_int_id;
			}
			StringParameter sp_int_province {
				IndexDomain: i_int_id;
			}
			StringParameter sp_int_countryAcronym {
				IndexDomain: i_int_id;
			}
		}
		Section LatLong_API {
			StringParameter sp_def_apiKey {
				Definition: "54c8e0e21241f8f235ff0e7329aa989b";
			}
			Procedure pr_callAPIQuery {
				Arguments: (sp_in_city,ep_in_cityCountry);
				Body: {
					!Deleting old info
					if DirectoryExists("out") then
					    DirectoryDelete("out");
					endif;
					DirectoryCreate("out");
					
					block ! fetch query 
					sp_loc_requestId := "fetch" + sp_in_city;
					
					sp_loc_urlCall 
					:=  "http://api.positionstack.com/v1/forward?access_key=" + sp_def_apiKey 
					    + "&query=" + sp_in_city 
					    + "&limit=1"
					    + "&country=" + sp_countryAcronym(ep_in_cityCountry);
					
					dex::client::NewRequest(
					        sp_loc_requestId,
					        sp_loc_urlCall,
					        'dex::client::EmptyCallback',
					        responsefile:"out/Output.json");
					
					dex::client::PerformRequest(sp_loc_requestId);
					dex::client::WaitForResponses(1000);    
					endblock;
					
					pr_readJSONOutput;
				}
				StringParameter sp_in_city {
					Property: Input;
				}
				ElementParameter ep_in_cityCountry {
					Range: s_countries;
					Property: Input;
				}
				StringParameter sp_loc_urlCall;
				StringParameter sp_loc_requestId;
			}
			Section Read_JSON_by_DEX {
				DeclarationSection LatLong {
					dex::Dataset: LatLongDataset;
					dex::TableName: LatLong;
					Set s_int_cities {
						Parameter: ep_int_city;
					}
					Index i_int_city {
						Range: s_int_cities;
						dex::ColumnName: name;
					}
					Parameter p_int_latitude {
						IndexDomain: i_int_city;
						dex::ColumnName: latitude;
					}
					Parameter p_int_longitude {
						IndexDomain: i_int_city;
						dex::ColumnName: longitude;
					}
				}
				Procedure pr_readJSONOutput {
					Body: {
						dex::AddMapping(
							mappingName :  "LatLongMapping", 
							mappingFile :  "Mappings/Generated/LatLongDataset.xml");
						
						delay(5);
						
						dex::ReadFromFile(
							dataFile         :  "out/Output.json", 
							mappingName      :  "LatLongMapping", 
							emptyIdentifiers :  1, 
							emptySets        :  1, 
							resetCounters    :  1);
						
						! Mapping to main data model
						ep_int_city := first(i_int_city);
						ep_city := StringToElement(s_cities, ep_int_city, 0);
						
						if ep_city and ep_int_city then
						    p_latitude(ep_city) := p_int_latitude(ep_int_city);
						    p_longitude(ep_city) := p_int_longitude(ep_int_city);
						endif;
					}
				}
			}
		}
	}
	Procedure MainInitialization {
		Body: {
			empty p_init_tourConnect,p_sim_tourConnect,p_cyc_tourConnect;
			
			p_init_tourInitialized := 0;
			p_sim_initialized  := 0;
			p_cyc_initialized  := 0;
		}
	}
	Procedure PostMainInitialization {
		Body: {
			pr_readWorldCities;
		}
	}
	Procedure MainExecution;
	Procedure PreMainTermination {
		Body: {
			return 1;
		}
	}
	Procedure MainTermination {
		Body: {
			return 1;
		}
		Comment: "We return 1 to make sure AIMMS does not ask to save a case when closing the project";
	}
}
